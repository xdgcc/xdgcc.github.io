<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Corner&amp;Coder</title>
  
  <subtitle>ゴウサク 码字の地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dapaner.top/"/>
  <updated>2022-03-31T03:02:47.539Z</updated>
  <id>http://dapaner.top/</id>
  
  <author>
    <name>ゴウサク</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="http://dapaner.top/2022/03/31/test/"/>
    <id>http://dapaner.top/2022/03/31/test/</id>
    <published>2022-03-31T03:02:47.000Z</published>
    <updated>2022-03-31T03:02:47.539Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://dapaner.top/2021/08/07/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://dapaner.top/2021/08/07/堆排序/</id>
    <published>2021-08-07T07:45:32.000Z</published>
    <updated>2021-08-07T12:50:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆的数据结构和相关性质"><a href="#堆的数据结构和相关性质" class="headerlink" title="堆的数据结构和相关性质"></a>堆的数据结构和相关性质</h2><p>逻辑结构为一个近似完全二叉树，具有完全二叉树的性质</p><p>物理结构为数组</p><p>A.length为数组中元素的个数</p><p>A.heap-size为存放在数组A中的堆的元素个数</p><p>A.length≥A.heap-size</p><p>对于某二叉树中的节点i，对应到数组A中的索引位置：</p><ol><li>i的父节点为⌊i&#x2F;2⌋（向下取整）</li><li>i的左子节点为2i</li><li>i的右子节点为2i+1</li></ol><p><code>注意：这里的乘除2的操作在实际代码中可以使用左移右移操作来提高效率</code></p><p>最大堆：A[PARENT(i)]≥A[i]<br>最小堆：A[PARENT(i)]≤A[i]</p><p><strong>只能保证树根是最大的或最小的！！！</strong></p><h2 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h2><h4 id="MAX-HEAPIFY"><a href="#MAX-HEAPIFY" class="headerlink" title="MAX-HEAPIFY"></a>MAX-HEAPIFY</h4><p>维护最大堆的性质</p><p>输入为数组A和下标i，<strong>以及堆的元素个数A.heap-size</strong></p><p>一个很重要的假定：<strong>假定根节点为LEFT(i)和RIGHT(i)的二叉树都是最大堆</strong>。即对于i来讲，它的左右子树已经都是最大堆了。</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">MAX-HEAPIFY</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">l = LEFT(i)</span><br><span class="line">r = RIGHT(i)</span><br><span class="line"></span><br><span class="line">if l &lt;= A.heap-size and A[l]&gt;A[i]</span><br><span class="line">largest = l</span><br><span class="line">else </span><br><span class="line">largest = i</span><br><span class="line"></span><br><span class="line">if r &lt;= A.heap-size and A[r] &gt; A[i]</span><br><span class="line">largest = r</span><br><span class="line"></span><br><span class="line">if largest != i</span><br><span class="line">exchange A[i] with A[largest]</span><br><span class="line">MAX-HEAPIFY(A, largest)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于一个数高为h的节点来说，MAX-HEAPIFY的时间复杂度为O(h)</p><h4 id="BUILD-MAX-HEAP"><a href="#BUILD-MAX-HEAP" class="headerlink" title="BUILD-MAX-HEAP"></a>BUILD-MAX-HEAP</h4><p>建堆</p><p>对于大小为n的数组A[1..n]来说，子数组A(⌊n&#x2F;2⌋+1..n)中的元素都是树的叶子节点</p><p>输入一个数组A</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">BUILD-MAX-HEAP</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">A.heap-size = A.length</span><br><span class="line"></span><br><span class="line">for i = ⌊A.length/2⌋ downto 1</span><br><span class="line">MAX-HEAPIFY(A, i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)，即可以在线性时间内讲一个无序数组构造成一个最大堆</p><h4 id="HEAPSORT"><a href="#HEAPSORT" class="headerlink" title="HEAPSORT"></a>HEAPSORT</h4><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">HEAPSORT</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">BUILD-MAX-HEAP[A]</span><br><span class="line">for i = A.length downto 2</span><br><span class="line">exchange A[1] with A[i]</span><br><span class="line">A.heap-size -= 1</span><br><span class="line">MAX-HEAPIFY(A, 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MAX-HEAP-INSERT"><a href="#MAX-HEAP-INSERT" class="headerlink" title="MAX-HEAP-INSERT"></a>MAX-HEAP-INSERT</h4><h4 id="HEAP-EXTRACT-MAX"><a href="#HEAP-EXTRACT-MAX" class="headerlink" title="HEAP-EXTRACT-MAX"></a>HEAP-EXTRACT-MAX</h4><h4 id="HEAP-INCREASE-KEY"><a href="#HEAP-INCREASE-KEY" class="headerlink" title="HEAP-INCREASE-KEY"></a>HEAP-INCREASE-KEY</h4><h4 id="HEAP-MAXIMUM"><a href="#HEAP-MAXIMUM" class="headerlink" title="HEAP-MAXIMUM"></a>HEAP-MAXIMUM</h4><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><h4 id="MIN-HEAPIFY"><a href="#MIN-HEAPIFY" class="headerlink" title="MIN-HEAPIFY"></a>MIN-HEAPIFY</h4><h4 id="BUILD-MINHEAP"><a href="#BUILD-MINHEAP" class="headerlink" title="BUILD-MINHEAP"></a>BUILD-MINHEAP</h4><h4 id="HEAPSORT-1"><a href="#HEAPSORT-1" class="headerlink" title="HEAPSORT"></a>HEAPSORT</h4><h4 id="MIN-HEAP-INSERT"><a href="#MIN-HEAP-INSERT" class="headerlink" title="MIN-HEAP-INSERT"></a>MIN-HEAP-INSERT</h4><h4 id="HEAP-EXTRACT-MIN"><a href="#HEAP-EXTRACT-MIN" class="headerlink" title="HEAP-EXTRACT-MIN"></a>HEAP-EXTRACT-MIN</h4><h4 id="HEAP-DECREASE-KEY"><a href="#HEAP-DECREASE-KEY" class="headerlink" title="HEAP-DECREASE-KEY"></a>HEAP-DECREASE-KEY</h4><h4 id="HEAP-MINIMUM"><a href="#HEAP-MINIMUM" class="headerlink" title="HEAP-MINIMUM"></a>HEAP-MINIMUM</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;堆的数据结构和相关性质&quot;&gt;&lt;a href=&quot;#堆的数据结构和相关性质&quot; class=&quot;headerlink&quot; title=&quot;堆的数据结构和相关性质&quot;&gt;&lt;/a&gt;堆的数据结构和相关性质&lt;/h2&gt;&lt;p&gt;逻辑结构为一个近似完全二叉树，具有完全二叉树的性质&lt;/p&gt;
&lt;p&gt;物
      
    
    </summary>
    
      <category term="算法" scheme="http://dapaner.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法导论 排序" scheme="http://dapaner.top/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统——内存</title>
    <link href="http://dapaner.top/2021/07/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
    <id>http://dapaner.top/2021/07/20/深入理解计算机系统——内存/</id>
    <published>2021-07-20T11:10:11.000Z</published>
    <updated>2021-07-21T16:53:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存，有层级概念hierarcy，多级缓存"><a href="#缓存，有层级概念hierarcy，多级缓存" class="headerlink" title="缓存，有层级概念hierarcy，多级缓存"></a>缓存，有层级概念hierarcy，多级缓存</h3><p>理想状态下，指令和存储构成最简单的计算机系统运算功能<br>内存大小限制<br>内存访问速度<br>cpu 算数逻辑单元ALU运算速度单位时间内运算速度有限</p><p>所以要1、提高计算速度2、提高I&#x2F;O速度<br>及对应两种设计理念——计算密集型和IO密集型</p><p>听说过迪奥西多城墙么？<br>cpu存在“内存之墙”。cpu运算速度再快，但因为其存在与内存之间IO的耗时，制约运算能力的并不是cpu的算力本身，而是“内存之墙”——内存IO</p><p>当前多核CPU成为常态，有一个关键问题需要解决——一致性问题consistency<br>存储在同一块内存里的资源被两个不同的核同时进行处理，需要做状态同步，保持一致<br>包括多级不同存储之间的同步 </p><p>缓存要解决的最重要的两个问题：<br>1、内存之墙<br>2、一致性问题</p><p>都用寄存器不行吗？<br>Locality局部性原理，尤其是在mem hierarcy的设计上<br>短时间内用到的有效存储是有限的，大部分是闲置的，都用寄存器成本太高</p><p>![](..&#x2F;..&#x2F;public&#x2F;img&#x2F;截屏2021-07-20 下午8.26.46.png)<br>![](..&#x2F;..&#x2F;public&#x2F;img&#x2F;截屏2021-07-20 下午8.32.08.png)<br>![](..&#x2F;..&#x2F;public&#x2F;img&#x2F;截屏2021-07-20 下午8.32.31.png)</p><h3 id="内存是怎么设计的"><a href="#内存是怎么设计的" class="headerlink" title="内存是怎么设计的"></a>内存是怎么设计的</h3><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><h3 id="虚拟内存，看到的都是虚拟内存"><a href="#虚拟内存，看到的都是虚拟内存" class="headerlink" title="虚拟内存，看到的都是虚拟内存"></a>虚拟内存，看到的都是虚拟内存</h3><h3 id="进程与内存关系、内存与指令集-进程上下文切换——中断系统（中断器）"><a href="#进程与内存关系、内存与指令集-进程上下文切换——中断系统（中断器）" class="headerlink" title="进程与内存关系、内存与指令集 进程上下文切换——中断系统（中断器）"></a>进程与内存关系、内存与指令集 进程上下文切换——中断系统（中断器）</h3><p>不管进程还是线程与虚拟内存的关系密切</p><p>进程间的内存空间是互相隔离的<br>线程间的内存空间是共用的</p><p>这里所说的内存地址空间，指的也都是虚拟内存</p><p>![](..&#x2F;..&#x2F;public&#x2F;img&#x2F;截屏2021-07-21 下午11.50.59.png)<br>![](..&#x2F;..&#x2F;public&#x2F;img&#x2F;截屏2021-07-21 下午11.54.54.png)</p><p>用户态下进程的虚拟地址控件分布如下图所示：<br>![](..&#x2F;..&#x2F;public&#x2F;img&#x2F;截屏2021-07-21 下午11.43.10.png)</p><p>线程间的内存空间是共用的，也为线程级并行计算提供了可能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缓存，有层级概念hierarcy，多级缓存&quot;&gt;&lt;a href=&quot;#缓存，有层级概念hierarcy，多级缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存，有层级概念hierarcy，多级缓存&quot;&gt;&lt;/a&gt;缓存，有层级概念hierarcy，多级缓存&lt;/
      
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://dapaner.top/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="CSAPP 操作系统" scheme="http://dapaner.top/tags/CSAPP-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode. 链表</title>
    <link href="http://dapaner.top/2021/07/03/Leetcode.%20%E9%93%BE%E8%A1%A8/"/>
    <id>http://dapaner.top/2021/07/03/Leetcode. 链表/</id>
    <published>2021-07-03T07:00:30.000Z</published>
    <updated>2021-08-15T03:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记住这些"><a href="#记住这些" class="headerlink" title="记住这些:"></a>记住这些:</h2><ol><li><p>虚头结点&amp;双指针就能解决大部分问题</p></li><li><p><strong>舍得用变量，千万别想着节省变量，否则容易被逻辑绕晕</strong></p></li><li><p><strong>head 有可能需要改动时，先增加一个 假head，返回的时候直接取 假head.next，这样就不需要为修改 head 增加一大堆逻辑了。</strong>往往这种时候，cur指针先指在dummynode，然后循环中使用cur&gt;next与cur-&gt;next-&gt;next，来进行遍历</p></li><li><p>画出遍历、移动等过程</p></li></ol><hr><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></p><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></p><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></p><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></p><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></p><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></p><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="虚头结点-amp-双指针感觉就能解决大部分问题"><a href="#虚头结点-amp-双指针感觉就能解决大部分问题" class="headerlink" title="虚头结点&amp;双指针感觉就能解决大部分问题"></a>虚头结点&amp;双指针感觉就能解决大部分问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);   <span class="comment">//设置一个虚拟头结点</span></span><br><span class="line">dummyHead-&gt;next = head;                  <span class="comment">//将虚拟头结点指向head，这样方面后面做操作</span></span><br><span class="line">ListNode* cur = dummyHead;               <span class="comment">//当前操作节点从虚头节点开始</span></span><br></pre></td></tr></table></figure><h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><ol><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点的数值</li></ol><p><a href="https://leetcode-cn.com/problems/design-linked-list/">力扣 707. 设计链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表节点结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>); <span class="comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (_size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123; <span class="comment">// 如果--index 就会陷入死循环</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最后面添加一个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果index大于链表的长度，则返回空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="反转链表（递归、迭代）"><a href="#反转链表（递归、迭代）" class="headerlink" title="反转链表（递归、迭代）"></a>反转链表（递归、迭代）</h4><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">力扣 206. 反转链表</a></p><h4 id="删除倒数第N个节点"><a href="#删除倒数第N个节点" class="headerlink" title="删除倒数第N个节点"></a>删除倒数第N个节点</h4><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">力扣 19. 删除链表的倒数第N个节点</a></p><h4 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h4><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">力扣 面试题 02.07. 链表相交</a></p><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">力扣 142. 环形链表II</a></p><h5 id="1-判断链表是否有环"><a href="#1-判断链表是否有环" class="headerlink" title="1.判断链表是否有环"></a>1.判断链表是否有环</h5><p>快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast 指针每次移动两个节点，slow 指针每次移动一个节点，如果 fast 和 slow 指针在途中相遇，说明这个链表有环。</p><h5 id="2-查找环的入口位置"><a href="#2-查找环的入口位置" class="headerlink" title="2.查找环的入口位置"></a>2.查找环的入口位置</h5><p>快慢指针，当第一次相遇时，快指针回到头节点，然后改为一次移动一个节点，下次相遇时的节点就是环入口节点</p><h3 id="经典操作"><a href="#经典操作" class="headerlink" title="经典操作"></a>经典操作</h3><p><strong>链表的题通常需要注意两点：</strong></p><ol><li><p><strong>舍得用变量，千万别想着节省变量，否则容易被逻辑绕晕</strong></p></li><li><p><strong>head 有可能需要改动时，先增加一个 假head，返回的时候直接取 假head.next，这样就不需要为修改 head 增加一大堆逻辑了。</strong></p></li></ol><p>往往这种时候，cur指针先指在dummynode，然后循环中使用cur&gt;next与cur-&gt;next-&gt;next，来进行遍历</p><p>可用作复杂题解的一部分</p><p>链表反转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        ListNode *cur = nullptr;</span><br><span class="line">        while(pre) &#123;</span><br><span class="line">            ListNode *tmp = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>链表中间节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode* middleNode(ListNode* head) &#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>合并升序链表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *dummyhead = new ListNode();</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        while(l1 != nullptr &amp;&amp; l2 != nullptr) &#123;</span><br><span class="line">            if(l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = l1 == nullptr ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        return dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除倒数第N个节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line"></span><br><span class="line">        if(head == nullptr) return nullptr;</span><br><span class="line"></span><br><span class="line">        ListNode *dummyNode = new ListNode(0,head);</span><br><span class="line">        ListNode *slow = dummyNode;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        int i = n;</span><br><span class="line">        while (i &gt; 0) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(fast) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        return dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>两个链表是否相交？返回相交的点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line"></span><br><span class="line">        if(headA == NULL || headB == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">        ListNode *pa = headA;</span><br><span class="line">        ListNode *pb = headB;</span><br><span class="line"></span><br><span class="line">        while (pa != pb) &#123;</span><br><span class="line"></span><br><span class="line">            pa = pa == NULL ? headB : pa-&gt;next;</span><br><span class="line">            pb = pb == NULL ? headA : pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pa;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除链表元素为a的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode *dummyNode = new ListNode(0, head);</span><br><span class="line"></span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line"></span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            if(cur-&gt;val == val) &#123;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pre = pre-&gt;next;        </span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记住这些&quot;&gt;&lt;a href=&quot;#记住这些&quot; class=&quot;headerlink&quot; title=&quot;记住这些:&quot;&gt;&lt;/a&gt;记住这些:&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;虚头结点&amp;amp;双指针就能解决大部分问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;舍得用变
      
    
    </summary>
    
      <category term="算法" scheme="http://dapaner.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>读《重构——改善既有代码的设计》</title>
    <link href="http://dapaner.top/2021/07/02/%E8%AF%BB%E3%80%8A%E9%87%8D%E6%9E%84%E2%80%94%E2%80%94%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    <id>http://dapaner.top/2021/07/02/读《重构——改善既有代码的设计》/</id>
    <published>2021-07-02T15:55:17.000Z</published>
    <updated>2021-07-02T16:03:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>重构后即运行测试。小步修改，每次修改后就运行测试，每次成功的重构后就提交代码，可以轻松地回滚到上一个可工作的状态。<br>好代码的检验标准就是人们能否能轻易的修改它。<br>软件的性能通常至于代码的一小部分相关，改变其他的部分往往对总体性能贡献甚微。对于重构过程中产生的性能问题，大多数情况下可以忽略它，先完成重构，再做性能优化。<br>编写软件是一个累加的过程，添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入。<br>当你感觉需要撰写注释时，请先尝试重构，试着让所有的注释都变得多余。<br>编写优良的测试程序，可以极大地提高编程速度，即使不进行重构也是如此。<br>类应该包含它们自己的测试代码。</p><h1 id="什么是重构"><a href="#什么是重构" class="headerlink" title="什么是重构"></a>什么是重构</h1><p>重构不应指代任何形式的代码清理，而应是运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。期间代码应很少进入不可工作的状态。<br>重构与性能优化相比，两者都需要修改代码，都不会改变程序的整体功能。差别在于目的，重构是为了让代码“更容易理解，更容易修改”，这可能是程序更快，或者更慢。而性能优化则是为了使程序运行更快。</p><h1 id="为什么重构"><a href="#为什么重构" class="headerlink" title="为什么重构"></a>为什么重构</h1><p>改进软件的设计<br>使软件容易理解<br>帮助找到bug<br>提高编程速度</p><h1 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h1><p><code>事不过三，三则重构</code></p><p>见机行事的重构——并不安排一段专门的时间进行重构，而是添加新功能或者修复bug时顺便重构。<br>预备性重构：最佳时机在添加新功能前。经常发现：如果对现有代码结构做一点微调，工作会变得容易的多。<br>帮助理解的重构：搞不懂这段代码在干什么，为了能清晰地理解。<br>捡垃圾式重构：我已经懂了这段代码在干什么，但他实在写的太烂了。眼下有空顺手重构了，眼下没空小本本记下来，后面再来清理。</p><p>有计划的重构——某个区域的问题逐渐积累长大，需要专门找一段时间处理肮脏的代码。但大部分重构应该是见机行事的。</p><h1 id="何时不应该重构"><a href="#何时不应该重构" class="headerlink" title="何时不应该重构"></a>何时不应该重构</h1><p>丑陋的代码被隐藏在一个API下，而我不需要理解其运行原理。<br>如果重写比重构还容易，就别重构了！</p><h1 id="重构的挑战"><a href="#重构的挑战" class="headerlink" title="重构的挑战"></a>重构的挑战</h1><p>重构是耗费时间的，它可能延缓新功能的开发。有时候是这样的，功能小而重构多。这需要做出取舍和权衡。但长远来看，重构应该还是能够创造更大的价值的。<br>重构不仅会影响参与重构的人，而且会影响整个团队的其他协同开发着，甚至是不同团队的开发者，关联方的影响会妨碍重构。<br>工作流的科学合理性很重要，代码的分支合并操作会带来很多问题。CI和重构能够良好配合，是有最佳实践的。<br>不改变程序可观察的行为，是重构的一个重要特征。要做到这一点关键在于如何快速的发现错误并修正。</p><h1 id="重构与架构、自测试代码、持续集成"><a href="#重构与架构、自测试代码、持续集成" class="headerlink" title="重构与架构、自测试代码、持续集成"></a>重构与架构、自测试代码、持续集成</h1><p>增量式设计（YAGNI, you aren’t going to need it），架构应该是能在不断重构中优化的<br>自测试代码是重构的基石<br>自测试代码、持续集成、重构——彼此之间有着很强的协同效应。</p><h1 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h1><ol><li>神秘命名</li><li>重复代码</li><li>过长函数</li><li>过长参数列表</li><li>全局数据</li><li>可变数据（要约束对数据的更新）</li><li>发散式变化（每次应只关心一个上下文，不同逻辑应分属不同模块）</li><li>霰弹式修改（遇到某种变化需要在许多不同的类内做出许多小修改，难找且容易遗漏）</li><li>依恋情节（一个函数与另一个模块的某个函数数据交流格外频繁，甚至超过自己所处模块的内部）</li><li>数据泥潭（？？？）</li><li>基本类型偏执（为了显示电话号码，用字符串代表电话号码数据，“类字符串类型变量”，是如此常见的臭味）</li><li>重复的switch</li><li>循环语句（以管道？取代循环）</li><li>冗赘的元素（简化，瘦身）</li><li>夸夸其谈通用性（hook、钩子）</li><li>临时字段</li><li>过长消息链</li><li>中间人</li><li>内幕交易（把数据交换放在明面上）</li><li>过大的类</li><li>异曲同工的类</li><li>纯数据类</li><li>被拒绝的遗赠（子类复用了超类的行为，却不愿意支持超类的接口）</li><li>注释（长长的注释之所以存在往往是因为代码很糟糕，重构后会发现，注释变的多余了）</li></ol><h1 id="如何重构"><a href="#如何重构" class="headerlink" title="如何重构"></a>如何重构</h1><h3 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h3><ol><li>提炼函数（Extract Function）</li><li>内联函数（Inline Function）</li><li>提炼变量（Extract Variable）</li><li>内联变量（Inline Variable）</li><li>改变函数声明（Change Function Declaration）</li><li>封装变量（Encapsulate Variable）</li><li>变量改名（Rename Variable） </li><li>引入参数对象（Introduce Parameter Object） </li><li>函数组合成类（Combine Functions into Class） </li><li>函数组合成变换（Combine Functions into Transform）</li><li>拆分阶段（Split Phase）</li></ol><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol><li>封装记录（Encapsulate Record） </li><li>封装集合（Encapsulate Collection） </li><li>以对象取代基本类型（Replace Primitive with Object） </li><li>以查询取代临时变量（Replace Temp with Query） </li><li>提炼类（Extract Class）</li><li>内联类（Inline Class） </li><li>隐藏委托关系（Hide Delegate） </li><li>移除中间人（Remove Middle Man） </li><li>替换算法（Substitute Algorithm）</li></ol><h3 id="搬移特性"><a href="#搬移特性" class="headerlink" title="搬移特性"></a>搬移特性</h3><ol><li>搬移函数（Move Function） </li><li>搬移字段（Move Field） </li><li>搬移语句到函数（Move Statements into Function） </li><li>搬移语句到调用者（Move Statements to Callers） </li><li>以函数调用取代内联代码（Replace Inline Code with Function Call） </li><li>移动语句（Slide Statements） </li><li>拆分循环（Split Loop） </li><li>以管道取代循环（Replace Loop with Pipeline）</li></ol><h3 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h3><ol><li>拆分变量（Split Variable） </li><li>字段改名（Rename Field） </li><li>以查询取代派生变量（Replace Derived Variable with Query） </li><li>将引用对象改为值对象（Change Reference to Value） </li><li>将值对象改为引用对象（Change Value to Reference）</li></ol><h3 id="简化条件逻辑"><a href="#简化条件逻辑" class="headerlink" title="简化条件逻辑"></a>简化条件逻辑</h3><ol><li>分解条件表达式（Decompose Conditional） </li><li>合并条件表达式（Consolidate Conditional Expression） </li><li>以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses） </li><li>以多态取代条件表达式（Replace Conditional with Polymorphism） </li><li>引入特例（Introduce Special Case） </li><li>引入断言（Introduce Assertion）</li></ol><h3 id="重构API"><a href="#重构API" class="headerlink" title="重构API"></a>重构API</h3><ol><li>将查询函数和修改函数分离（Separate Query from Modifier） </li><li>函数参数化（Parameterize Function） </li><li>移除标记参数（Remove Flag Argument） </li><li>保持对象完整（Preserve Whole Object） </li><li>以查询取代参数（Replace Parameter with Query） </li><li>以参数取代查询（Replace Query with Parameter） </li><li>移除设值函数（Remove Setting Method） </li><li>以工厂函数取代构造函数（Replace Constructor with Factory Function） </li><li>以命令取代函数（Replace Function with Command） </li><li>以函数取代命令（Replace Command with Function）</li></ol><h3 id="处理继承关系"><a href="#处理继承关系" class="headerlink" title="处理继承关系"></a>处理继承关系</h3><ol><li>函数上移（Pull Up Method） </li><li>字段上移（Pull Up Field） </li><li>构造函数本体上移（Pull Up Constructor Body） </li><li>函数下移（Push Down Method） </li><li>字段下移（Push Down Field） </li><li>以子类取代类型码（Replace Type Code with Subclasses） </li><li>移除子类（Remove Subclass） </li><li>提炼超类（Extract Superclass） </li><li>折叠继承体系（Collapse Hierarchy） </li><li>以委托取代子类（Replace Subclass with Delegate） </li><li>以委托取代超类（Replace Superclass with Delegate）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;重构后即运行测试。小步修改，每次修改后就运行测试，每次成功的重构后就提交代码，可以轻松地回滚到上一个可工作的状态。&lt;br&gt;好
      
    
    </summary>
    
      <category term="基础能力" scheme="http://dapaner.top/categories/%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B/"/>
    
    
      <category term="读书笔记" scheme="http://dapaner.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读《禅与 Objective-C 编程艺术》</title>
    <link href="http://dapaner.top/2019/07/10/%E8%AF%BB%E3%80%8A%E7%A6%85%E4%B8%8E-Objective-C-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B/"/>
    <id>http://dapaner.top/2019/07/10/读《禅与-Objective-C-编程艺术》/</id>
    <published>2019-07-10T01:24:05.000Z</published>
    <updated>2019-07-26T05:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于单例"><a href="#关于单例" class="headerlink" title="关于单例"></a>关于单例</h1><p>要注意两个问题，一是线程安全问题；二是要确保它是一个单例。</p><p>线程安全问题推荐通过使用 dispatch_once() 来解决，取代 iOS4.0 之前没有 GCD 时期使用的 @synchronized 方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">   static id sharedInstance = nil;</span><br><span class="line">   static dispatch_once_t onceToken = 0;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">      sharedInstance = [[self alloc] init];</span><br><span class="line">   &#125;);</span><br><span class="line">   return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_once() 的优点是，它更快，而且语法上更干净。同时可以避免 <a href="https://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html">possible and sometimes prolific crashes</a> 。《Effective Objective-C 2.0》在《块与大中枢派发》一章中也有关于使用 dispatch_once() 来创建单例的说明，从安全和性能两个角度说明了为什么要使用 dispatch_once() 。</p><blockquote><p>使用 dispatch_once() 可以简化代码并且彻底保证线程安全，开发者根本无需担心加锁或者同步。所有问题都由GCD底层处理。由于每次调用时都必须使用完全相同的标记，所以标记要声明成static。把该变量定义在static作用域中，可以保证编译器在每次执行sharedInstance方法时都会复用这个变量，而不会创建新变量。</p><p>此外，dispatch_once() 更高效。它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用“原子访问”（atomic access）来查询标记，以判断其所对应的代码是否已经执行过。笔者在自己装有64位 Mac OS X 10.8.2 系统的电脑上简单测试了性能，分别采用 @synchronized 方式以及 dispatch_once() 方式来实现sharedInstance方法，结果显示，后者速度几乎是前者的两倍。</p><p>—— 引自《Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法》</p></blockquote><p>上面这段代码看上去好像没什么问题，但是真的就能确保这样创建的单例，它一定是一个单例吗？</p><p>看看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-97333-CJBDDIBI">苹果文档</a>中创建一个单例的代码和过程：</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static MyGizmoClass *sharedGizmoManager = nil;</span><br><span class="line"> </span><br><span class="line">+ (MyGizmoClass*)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    if (sharedGizmoManager == nil) &#123;</span><br><span class="line">        sharedGizmoManager = [[super allocWithZone:NULL] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedGizmoManager;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (id)allocWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    return [[self sharedManager] retain];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (id)retain</span><br><span class="line">&#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (NSUInteger)retainCount</span><br><span class="line">&#123;</span><br><span class="line">    return NSUIntegerMax;  //denotes an object that cannot be released</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)release</span><br><span class="line">&#123;</span><br><span class="line">    //do nothing</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (id)autorelease</span><br><span class="line">&#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程：</p><ol><li>It declares a static instance of your singleton object and initializes it to nil.</li><li>In your class factory method for the class (named something like “sharedInstance” or “sharedManager”), it generates an instance of the class but only if the static instance is nil.</li><li>It overrides the allocWithZone: method to ensure that another instance is not allocated if someone tries to allocate and initialize an instance of your class directly instead of using the class factory method. Instead, it just returns the shared object.</li><li>It implements the base protocol methods copyWithZone:, release, retain, retainCount, and autorelease to do the appropriate things to ensure singleton status. (The last four of these methods apply to memory-managed code, not to garbage-collected code.)</li></ol><p>注意上面的步骤3、步骤4。</p><p>步骤3在创建单例时是有重写 allocWithZone: 方法来避免通过调用 alloc、allocWithZone 创建另一个实例出来。</p><p>步骤4重写了遵循 NSCopying 协议的 copyWithZone: 方法，来避免调用 copy 方法时产生崩溃（对于自己定义的类，要实现 copy 就要默认实现 NSCopying 协议，同理实现mutablecopy 就要实现 NSMutableCopying 协议，否则调用相应 copy 方法时会引起崩溃）。</p><p>步骤4还重写了部分内存管理相关的方法，这些方法有些在 ARC 时代已经可以不用管他们了。</p><p>综上，写一个单例时要注意的三个点：</p><ol><li>使用 dispatch_once() 来保证线程安全和性能。</li><li>重写 allocWithZone: 方法来避免通过调用 alloc、allocWithZone 创建另一个实例出来。</li><li>重写遵循 NSCopying、NSMutableCopying 协议的方法，避免调用相关copy方法时崩溃。</li></ol><h1 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h1><p>在 Objective-C 里是通过 protocol 来实现抽象接口的。Apple 几乎只是在委托模式下使用 protocol。但是，在一些场景下，使用 protocol 可以把非常糟糕的设计的架构改造为一个良好的可复用的代码。</p><h1 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h1><p>S——单一对象原则<br>O——开闭原则<br>L——里氏替换原则<br>I——接口隔离原则<br>D——依赖反转原则</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于单例&quot;&gt;&lt;a href=&quot;#关于单例&quot; class=&quot;headerlink&quot; title=&quot;关于单例&quot;&gt;&lt;/a&gt;关于单例&lt;/h1&gt;&lt;p&gt;要注意两个问题，一是线程安全问题；二是要确保它是一个单例。&lt;/p&gt;
&lt;p&gt;线程安全问题推荐通过使用 dispatch_onc
      
    
    </summary>
    
      <category term="iOS" scheme="http://dapaner.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://dapaner.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>愉快的leetcode</title>
    <link href="http://dapaner.top/2019/06/23/%E6%84%89%E5%BF%AB%E7%9A%84leetcode/"/>
    <id>http://dapaner.top/2019/06/23/愉快的leetcode/</id>
    <published>2019-06-23T00:20:13.000Z</published>
    <updated>2021-07-02T16:12:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇分享的时候，回忆起上大学那会儿的算法课，现在想起来都瑟瑟发抖。课本是三大圣经之一的《算法导论》，我们一群刚从从新手村里出来的弱鸡，看着前面这座大山，内心十分抗拒。那会儿的想法是，学这个有用吗？其实不光是算法，西电在本科期间设置的课程大多不涉及工程领域，四年时间，三年半都在学数据结构、算法、计算机导论、编译原理、计算机网络这些CS专业基础课，而且由于在当时看来这些课程本身没有太大联系，学的时候内心是充满困惑的。但现在看来，还是那时太年轻啊，工作之后面临的新技术，其实一点儿都不“新”。那些所谓的新技术，核心和本质的东西其实就是当初学的那些基础知识。掌握了这些基础之后，学任何东西都很快。现在我的理解是，<strong>基础知识就是大楼的地基，它决定我们的技术高度。</strong></p><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>当你准备开始学习、回炉算法的时候，你已经意识到它是什么了。</p><h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>当然是为了用。</p><p><strong>1、最直接的就是能够写出高性能的代码。</strong></p><p>对于iOSer来说，尤其我们平时做业务为主，感觉平时用到算法的地方不多，但只不过是苹果爸爸给我们封装好了而已，我们用的很多API，底层的东西都涉及到了数据结构和算法，只不过我们不用动手去实现。相较于后端来说可能自己用算法实现一些东西的机会会多一些。我就以我个人的经验举几个栗子🌰说明一下：</p><p>先说一个前两天碰到的，就咱们孕管的代码。帖子详情页的实现有四个地方存在内存问题，其中这个比较严重的直接导致在某些机型上内存撑爆gg。</p><p><img src="http://image.dapaner.top/WX20190627-160937.png"></p><p>ok，那么问题来了，也是一个经典的关于OC内存管理的iOS面试题：ARC下的 autoreleasepool 是什么，怎么用，它是怎么实现的？这里只说它的实现。</p><p>autoreleasepool的本质，或者说实现是一个<strong>与线程绑定的、以栈为节点的双向链表</strong>，很明显，它利用了链表的两个特性或者说优点才能达到帮我们释放内存的工作，即<strong>采用动态存储分配，不会造成内存浪费和溢出</strong>；<strong>执行插入和删除操作十分方便，是修改指针的操作，不需要移动大量元素</strong>。</p><p>通常情况下，我们是不需要手动添加 autoreleasepool 的，使用线程自动维护的 autoreleasepool 就好了。根据苹果官方文档中对 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI">Using Autorelease Pool Blocks</a> 的描述，我们知道在下面三种情况下是需要我们手动添加 autoreleasepool 的：</p><p><img src="http://image.dapaner.top/Snip20190623_8.png"></p><p>回到孕管代码里这个问题，属于第二种情况，PHForumDetialItemAnalysis 的set方法中，有大量的计算，而且创建了大量的占用内存的临时变量并且没有及时释放，导致了这个问题。</p><p>再说一个后端的栗子🌰吧，这个其实更具有代表性。场景是去年在上家公司”不务正业“去重写了公司的新的搜索后端服务。先简单列一下战果吧：</p><table><thead><tr><th></th><th>资源占用（服务器配置）</th><th>搜索效率 &amp; 搜索质量</th></tr></thead><tbody><tr><td>老搜索</td><td>8核16G内存</td><td>一般</td></tr><tr><td>新搜索</td><td>双核4G内存</td><td>巨幅提升</td></tr></tbody></table><p>搜索服务是高内存需求的，重写后的新搜索在资源占用和搜索质量上都有了明显的提高。原因在哪呢，还是因为具体的实现有本质区别。<br>老的搜索是纯代码实现，没有借助任何的开源搜索引擎，大部分搜索相关功能是 <strong>数据库（MySQL）</strong> 和 <strong>redis</strong> 来实现的，索引丢在redies的cache里面，在公司业务初期数据量不大的情况下也还ok，能撑得住，但是到后面公司的数据积累越来越大，老的搜索执行效率就开始出现问题了。所以才有了要重写新搜索的需求。</p><p>经过初期技术调研后，考虑到公司实际的业务和数据规模，新搜索决定基于 <strong>Elasticsearch</strong> 来做，关于 Elasticsearch 这里就不多说了，其实运维用的比较多，属于比较常见的ELK架构的一部分，很多用来搞日志分析的。新搜索之所以较老搜索有速度上的巨幅提升，根本原因还是在于 MySQL 和 Elasticsearch 索引方式的不同——Elasticsearch 使用的 <strong>倒排索引</strong> 比 MySQL 的 <strong>B-Tree索引</strong> 快。</p><p>呐，那么这两种索引算法的使用就是至关重要的了。关于倒排索引，它又包含了很多的数据结构和算法在里面。。。</p><p>所以说，<strong>掌握了数据结构与算法，看待问题的深度，解决问题的角度和方式就会完全不一样</strong>。</p><p><strong>2、大厂面试必备。</strong></p><p>我觉得，这两个理由，足够了。当然作为程序员的”内功“，还有更多理由去学习数据结构和算法，就不多提了。高手闯荡江湖，哪怕一招儿鲜，那也得是内功深厚的一招儿鲜。</p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>第一步注册leetcode账号：<br><a href="https://leetcode.com/problemset/all/">英文版</a> or <a href="https://leetcode-cn.com/problemset/all/">中文版</a></p><p>其实区别不大，之前中文版的题目稍微少些，现在同步的差不多了。而且现在英文版账号已经可以同步到中文版了。<br>简单的了解一下这个网站的使用： <a href="https://support.leetcode-cn.com/hc/kb/category/1018381/">leetcode入门指南</a></p><h2 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h2><p>其实从前面也可以看出来，数据结构和算法是不分家的。它们都<strong>是前人从很多实际操作场景中抽象出来的</strong>，都是些比较经典的东西。之前说基础就是地基，下面介绍一下打地基所用的材料们：</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>为什么要进行代码的复杂度分析？其实把代码跑过一遍以后通过一些比如IDE的监控啊什么的我们就能知道这段代码的执行效率了，包括用时啊、内存占用啊、CPU占用啊之类的，但这都属于事后诸葛。。。而且有很大的局限性：</p><ol><li>受测试环境（比如硬件配置）影响大。同一段代码，不同机器运行，我配置牛逼就是跑的快，充钱的自然是爸爸，这在哪都是同样的道理，简单粗暴。</li><li>受测试数据不同而影响大。就拿排序来讲，比如对同一个排序算法而言，测试用例的有序度不一样，在相同环境下执行时间肯定是不同的；再比如不同的排序算法，由于数据规模不一样，很可能执行时间的结果也有较大差异，就几个数据排排序，可能插入排序就比快排快，但是你能说插入排序就是比快排快吗？数据量上万、上千万的时候呢？</li></ol><p>综上，我们必须要做马前卒而不是马后炮，需要一个<strong>不依赖测试环境</strong>、<strong>不依赖测试数据</strong>、<strong>不需要代码执行</strong>就能衡量代码执行效率的标准或者方法，就是<strong>时间复杂度</strong>和<strong>空间复杂度</strong>分析。</p><h4 id="时间复杂度——大O表示法"><a href="#时间复杂度——大O表示法" class="headerlink" title="时间复杂度——大O表示法"></a>时间复杂度——大O表示法</h4><p>时间复杂度可以简单地理解为<strong>执行这段代码所需要的时间</strong>。</p><p>举个栗子🌰先：</p><p>一个非常简单的求0~n的和的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= n; i++) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据计算机组成原理里的相关知识，从 CPU 的角度来看，这段代码的每一行，CPU 都要进行以下操作：<strong>读数据-运算-写数据</strong>。当然了，每行代码对应的 CPU 执行次数、执行的时间都不一样，但是这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为一个单位时间常数 t。在这个假设的基础之上，来看下这段代码的总执行时间是多少。</p><p>第 2、3 行代码分别需要 1 个 t 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*t 的执行时间，所以这段代码总的执行时间就是 T(n) &#x3D;<font color=#FF0000> (2n+2) </font> *t 。可以看出来， T(n) 与每行代码的执行次数 n 成正比。</p><p>再来个循环嵌套的代码瞅瞅：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= n; i++) &#123;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">sum = sum +  i * j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 2、3、4 行代码，每行都需要 1 个 t 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n*t 的执行时间，第 7、8 行代码循环执行了 n^2 遍，所以需要 2n^2 *t 的执行时间。所以，整段代码总的执行时间 T(n) &#x3D; <font color=#FF0000> (2n^2 + 2n+3) </font>*t。同样，T(n) 与每行代码的执行次数 n 也成正比 。</p><p>尽管我们不知道单位时间 t 的具体时长，但我们能看出来：<strong>一段代码的执行时间 &#x3D; 代码总执行次数*单位时间</strong> ,总结成一个公式就是大O表示法了：</p><center> T(n) = O(f(n)) </center><p>具体解释一下这个公式。其中，T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示，就是上面的<font color=#FF0000>红色部分</font>。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比，就是单位时间的 t 倍。</p><p>所以，替换一下就可以知道：第一个栗子🌰中的 T(n) &#x3D; O(2n+2)，第二个栗子🌰中的 T(n) &#x3D; O(2n^2+2n+3)。这就是大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度（asymptotic time complexity）</strong>，简称时间复杂度。</p><p>其实很简单，当 n 很大时，决定多项式规模的是多项式中最高阶单项式。所以我们可以忽略多项式中低阶、常量、系数三部分，只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以简记为：</p><center> T(n) = O(n) </center><center> T(n) = O(n^2 ) </center><p>到这里剩下的事儿其实很简单了，上面是讲原理所以看上去很复杂，其实上面那两段代码打眼一看就知道复杂度是多少：</p><ul><li><p>只关注循环次数对多的那段代码</p></li><li><p>加法法则——总复杂度等于量级最大的那段代码的复杂度</p><ul><li>比如上面那两段代码放在一个方法里面，那这个新的方法的复杂度就是由后面那段代码决定的，也是 O(n^2 )</li></ul></li><li><p>乘法法则——嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p><ul><li>还是上面那哥儿俩，比如在第一个方法的循环中调用了第二个方法，则 T(n) &#x3D; T1(n) * T2(n^2 ) &#x3D; O(n*n^2 ) &#x3D; O(n^3 )</li></ul></li></ul><p>关于这个 <strong>大O</strong> 有很多图和文章总结比较各种数据结构、算法的复杂度以及不同复杂度的对比，google一下 <a href="https://www.google.com/search?q=big+o+cheat+sheet">big o cheat sheet</a> 巨多，可以去看下。这张来自 <a href="https://bigocheatsheet.com/">bigocheatsheet.com</a> 的比较著名的一张图po一下：</p><p><img src="http://image.dapaner.top/C4dP_w5UcAAP_hb.jpg"></p><h4 id="几种常见的时间复杂度"><a href="#几种常见的时间复杂度" class="headerlink" title="几种常见的时间复杂度"></a>几种常见的时间复杂度</h4><p>这里主要列几种常见的多项式类型的时间复杂度，非多项式类型的 O(2^n ) 和 O(n!) ,当数据规模 n 越来越大时，这哥儿俩执行时间会急剧增加，无限增长，效率十分低下，就不多提了。</p><ul><li>O(1)</li></ul><p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码，它与输入数据的规模无关。比如这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">8</span>;</span><br><span class="line"> <span class="type">int</span> j = <span class="number">6</span>;</span><br><span class="line"> <span class="type">int</span> sum = i + j;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><ul><li>O(logn)、O(nlogn)</li></ul><p>对数阶的这种其实很常见，但又贼难看，很恶心。举个栗子🌰看下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是看循环次数先，第 4 行这个语句决定什么时候跳出循环。i 每次循环的值变化为：2、4、8、16…即 k 次循环后值为 2^k 。跳出循环的条件为 i &lt;&#x3D; n 则求执行了多少次 k 为：2^k &#x3D; n , k &#x3D; log<sub>2</sub>n 。所以这段代码的时间复杂度就是 O(log<sub>2</sub>n) 。</p><p>同理，下面这段代码的时间复杂度就是 O(log<sub>3</sub>n) 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就有个说法了，根据换底公式，对数是可以互相转化的，因为 log<sub>3</sub>n &#x3D; log<sub>3</sub>2 * log<sub>2</sub>n ，所以 O(log<sub>3</sub>n) &#x3D; O(常数*log<sub>2</sub>n) ，又因为我们可以忽略系数，所以这种对数的时间复杂度统一表示为O(logn) 。</p><p>O(nlogn) 就是根据前面乘法法则来的，O(logn) 中嵌套了个循环就变 O(nlogn) 。</p><ul><li>O(n)、O(n^k )</li></ul><p>这个不说了。。。就是几层循环的问题。。。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>这个就比较好理解了，就是某段代码运行所占用的空间。还是举个栗子🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>[] a = new <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">a[i] = i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">print out a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个，第 2 行，申请了一个空间储存 i ，算是额外空间，但是跟我们的数据规模 n 没有关系，所以直接忽略。第 3 行申请了大小为 n 的空间，这个算 O(n) ，除此之外没有占用额外的空间了，所以时候这段代码的空间复杂度为 O(n) 。</p><p>需要注意的是，在刷leetcode的时候，我们其实关注的更多的空间复杂度在于某段代码执行时所需要的额外空间，比如给个简单的数组排序，题目中给出的目标数组本身所占用的空间我们可以忽略，比如冒泡排序这种不需要开辟额外的辅助空间的算法空间复杂度就是 O(1) ，快排这种需要额外的辅助空间的，就需要 O(nlogn) 了。</p><h3 id="数据结构与算法的概念-amp-基础实现（随时补充）"><a href="#数据结构与算法的概念-amp-基础实现（随时补充）" class="headerlink" title="数据结构与算法的概念&amp;基础实现（随时补充）"></a>数据结构与算法的概念&amp;基础实现（随时补充）</h3><p>概念和特性还是要比较熟练的掌握的，要不然下面的流程走不下去了。。当然，一些基础结构的基础实现也是应该熟记于心的，要不然真到了写代码的时候要用某个结构，发现这个结构怎么实现都写半天写不出来。。。那就基本gg了，有再好的算法思路都没用。</p><h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><ul><li><p>数组</p><ul><li>数组的索引为什么从0开始？</li></ul><p>  挺有意思的一个小东西：</p><p>  数组在实现随机访问的时候，比如a[i]是怎么访问的。“索引”或者“下标”的本质其实应该是<strong>“偏移量”</strong>。</p><p>  数组的访问下标从0开始与从1开始的区别，其实本质上是 <strong>a[i]_address &#x3D; base_address + i * type_size</strong> 与 *<em>a[i]_address &#x3D; base_address + (i-1)<em>type_size</em></em> 的区别。如果 a 是数组在内存中的首地址，那么访问 a[i] 时，计算其地址的公式分别为上面那俩。可以看到，后者多了一次减法运算。</p><p>  深入到CPU的层面，这里就多了一次减法指令，其实好像也没什么问题。。。对于现在的CPU来说差别好像不是很大，但要知道数组作为最基础的数据结构之一，其随机访问又是很基础的操作之一，效率的优化是要尽可能做到极致的，越往底层越是这样。上面提到了减法指令，为什么说多一个减法指令就会影响效率的问题，原因呢涉及到一部分《计组》的知识，关于CPU是怎么通过ALU完成最基本的加减操作的，这个不多展开。写到这里突然想起两个事儿，一个是当年被《计组》支配的恐惧，二是后来发现的网易公开课上<a href="http://open.163.com/movie/2018/5/M/S/MDGEPAQ4K_MDGET74MS.html">一套关于CS的科普类型的专辑视频</a>，挺好玩的，覆盖面比较全，虽然没那么系统、细致，但是我看前面讲计算机底层的一些底层概念的部分还是相当相当不错的，通俗易懂还有动画，比尼玛啃大部头的《计组》舒服多了，后悔当年刚学《计组》的时候咋没发现呢。。。大学一个学期整明白都费劲的东西，十几分钟就给你安排的明明白白。。。po张图感受下，墙裂推荐给大伙儿~</p></li></ul><p><img src="http://image.dapaner.top/Snip20190627_26.png"></p><ul><li><p>链表</p><ul><li>单链表、双向链表、循环链表实现以及基本的CURD操作</li></ul><p>  这里要特别注意边界条件的处理，特别是对头节点、尾节点、空链表的处理。建议引入<strong>哨兵节点</strong>简化部分判空操作。</p><p>  很多情况下，需要处理当前节点的前驱节点，如果是没有哨兵节点的链表，对第一个节点，即头节点，没有前驱节点。如果不作特殊处理，就可能出错；如果对它特别对待，就会增加代码复杂性，还会降低程序效率。而如果有哨兵节点的话， 线性表的每个位置的节点都有前驱节点，因此可以统一处理。这时候在考虑边界条件的时候往往只需要关注尾节点就好，省去了一些麻烦。</p><p>  ”哨兵“的应用除了在这里还有几个比较常见的情况，比如快排我们选取的基点就是一个哨兵，上面提到的 autoreleasepool 的实现原理中，OC也是通过”哨兵“来解决autoreleasepool的嵌套问题的，回头看完栈结构的时候可以再多聊一下。</p><ul><li>应用场景较多，往往链表会结合其他数据结构一起使用，比如拿散列表作链表的节点来实现高效的LRU算法等。</li></ul></li><li><p>栈</p></li><li><p>队列</p></li><li><p>散列表</p></li><li><p>二叉树</p></li><li><p>Trie树</p></li><li><p>堆</p></li><li><p>图</p></li><li><p>。。。</p></li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li>递归</li><li>排序</li><li>二分查找</li><li>搜索</li><li>哈希</li><li>贪心</li><li>分治</li><li>回溯</li><li>动态规划</li><li>字符串匹配</li><li>。。。</li></ul><h3 id="leetcode题目（随时补充）"><a href="#leetcode题目（随时补充）" class="headerlink" title="leetcode题目（随时补充）"></a>leetcode题目（随时补充）</h3><p>初次刷题或者对于我们而言，按照数据结构和算法分成多个小的模块，选取部分模块进行刷题就足够了，很多难度偏大和用得比较少的也不用去浪费时间在上面。</p><h4 id="数据结构：-1"><a href="#数据结构：-1" class="headerlink" title="数据结构："></a>数据结构：</h4><ul><li><p>数组</p><ul><li>两数之和：<a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></li><li>查找重复数字：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></li></ul><p>  上面这个查找重复数字题有一个更基础一点的，来自《剑指offer》：</p><blockquote><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字,要求:复杂度为 O(N) + O(1)。例如，如果输入长度为 7 的数组 {2, 3, 1, 6, 0, 2, 5}，那么对应的输出是第一个重复的数字 2。注意：如果某些数字不在 0 ~ n-1 的范围内，或者数组中不包含重复的数字，则返回 -1。  </p></blockquote></li><li><p>链表</p><ul><li>删除链表的倒数第N个节点：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></li><li>合并两个有序链表：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></li><li>环形链表：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></li><li>反转链表：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></li><li>链表的中间结点：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></li></ul></li><li><p>栈</p></li><li><p>队列</p></li><li><p>散列表</p></li><li><p>二叉树</p></li><li><p>Trie树</p></li><li><p>堆</p></li><li><p>图</p></li><li><p>。。。</p></li></ul><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul><li>递归</li><li>排序</li><li>二分查找</li><li>搜索</li><li>哈希</li><li>贪心</li><li>分治</li><li>回溯</li><li>动态规划</li><li>字符串匹配</li><li>。。。</li></ul><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>理想很丰满：看题——有思路——设计算法——写代码——通过</p><p><img src="http://image.dapaner.top/WX20190623-152918.png-small"> </p><p>显示很骨感：看题——这啥啊——不会啊——想不出来啊——算了算了</p><p><img src="http://image.dapaner.top/Snip20190623_9.png"></p><p>为了避免被题恶心晕的情况，给大家推荐一个刷题思路吧：</p><ol><li>读题</li><li>。。。直接看答案，没错，直接看答案</li><li>背答案手书默写</li><li>leetcode作答，搞定一个解法</li><li>多思路、多解法</li><li>复杂度优化</li><li>二刷、三刷、四刷、五刷。。。。</li></ol><p>需要注意的一点是，leetcode的测试用例会有考虑边界与极端情况，所以我们在写代码的时候也要考虑到，健壮性还是很重要的~</p><p><strong>最后，祝各位刷的愉快 ^.^</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写这篇分享的时候，回忆起上大学那会儿的算法课，现在想起来都瑟瑟发抖。课本是三大圣经之一的《算法导论》，我们一群刚从从新手村里出来的弱鸡，看着前面这座大山，内心十分抗拒。那会儿的想法是，学这个有用吗？其实不光是算法，西电在本科期间设置的课程大多不涉及工程领域，四年时间，三年半
      
    
    </summary>
    
      <category term="算法" scheme="http://dapaner.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://dapaner.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>重新起飞</title>
    <link href="http://dapaner.top/2019/06/14/%E9%87%8D%E6%96%B0%E8%B5%B7%E9%A3%9E/"/>
    <id>http://dapaner.top/2019/06/14/重新起飞/</id>
    <published>2019-06-14T14:20:13.000Z</published>
    <updated>2019-06-23T09:23:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>15年搭了这个blog，那会儿才刚开始学iOS的时候，零零碎碎写了写东西就急急忙忙的去实习、校招、毕业…..各种各种，后来工作之后的大部分笔记都放在了Evernote上，也没怎么整理发出来。</p><p>其实还是应该多写写东西发出来的，有产出才算真的理解某个东西。所以时隔将近四年决定重新装修一下开门儿营业，再次起飞。</p><p>还是又重新折腾了一番，换了个主题，把统计啊评论什么的接进来，hexo的命令都忘得差不多了。。。</p><p>之前的用的七牛免费的图床也挂了，寻思着挂了就挂了吧，正好有台机器闲着，回头搭个自己的图床算了。结果发现自己图都整不出来，还得配个自己的域名上去。。。shit！</p><p>好吧，那就顺便搞个域名，正好也给blog主站用好了。又去买域名、做备案，前前后后折腾了又有半个多月（还真是麻烦呢）。总算是备案好了，域名是 <a href="http://dapaner.top/">dapaner.top</a>，欢迎常来看看~</p><p>搞完域名解析什么的之后配到七牛的对象存储服务，把我老文章的图又捞回来了，寻思着新的图暂时也先放在这里吧，回头自己有时间折腾图床了再迁吧。 </p><p>在给自己blog主站配域名的时候碰到了个小麻烦，因为是托管在github的，需要在<a href="https://pages.github.com/">github pages</a>配置域名，需要把我的域名通过CHAME的方式指向我在github托管的仓库，问题就出在这里。为了不在每次 <code>hexo d</code> 之后都要重新配置域名，需要在hexo源文件中添加CHAME文件，添加需要绑定的我自己的域名，网上的一致结论是放在hexo的source目录下，到我这边不行了，最后折腾半天发现放在public目录下ok了。至于为什么，这得回头研究下source目录同步到public目录的机制以及git到底从哪里取我的CHAME文件来看了。。。</p><p>总之经过一番折腾之后总算是可以重新起飞了，后面打算写点原创的高质量的东西出来，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;15年搭了这个blog，那会儿才刚开始学iOS的时候，零零碎碎写了写东西就急急忙忙的去实习、校招、毕业…..各种各种，后来工作之后的大部分笔记都放在了Evernote上，也没怎么整理发出来。&lt;/p&gt;
&lt;p&gt;其实还是应该多写写东西发出来的，有产出才算真的理解某个东西。所以时隔
      
    
    </summary>
    
      <category term="杂" scheme="http://dapaner.top/categories/%E6%9D%82/"/>
    
    
      <category term="随笔" scheme="http://dapaner.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>XML/JSON数据解析</title>
    <link href="http://dapaner.top/2015/11/09/iOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94XML-JSON%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://dapaner.top/2015/11/09/iOS开发——XML-JSON数据解析/</id>
    <published>2015-11-09T02:33:03.000Z</published>
    <updated>2019-06-16T07:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>除了XML和Json，文中还涉及到的一些知识：第三方类库的使用，获取本地文件内容，网站API使用，GCD多线程编程，不做详细介绍，在代码出现的地方会注明。</p></blockquote><p>先安利一波：</p><p><a href="http://baike.baidu.com/view/136475.htm">Json</a><br><a href="http://baike.baidu.com/view/159832.htm?fromtitle=xml&fromid=86251&type=syn">XML</a></p><p>大数据时代，我们需要从网络中获取海量的新鲜的各种信息，就不免要跟着两个家伙打交道，这是两种结构化的数据交换格式。一般来讲，我们会从网络获取XML或者Json格式的数据，这些数据有着特定的数据结构，必须对其进行解析，得到我们可以处理的数据。所谓“解析”，就是从事先规定好的格式串中提取数据。解析的前提是数据的提供方与获取方提前约定好格式，数据提供方按照格式提供数据，数据获取方按照格式获取数据。</p><p>iOS开发中，几乎只要是与网络相关的应用，都离不开对网络数据的解析与应用。现总结几种常用方式来解析网络数据：</p><ul><li>Json格式：<ul><li>NSJSONSerialization，官方提供的Json数据格式解析类，iOS5以后支持</li><li>JSONKit（第三方类库）</li><li>SBJson</li><li>TouchJson</li></ul></li><li>XML格式：<ul><li>NSXMLParse，官方自带</li><li>GDataXML，Google提供的开元XML解析库</li></ul></li></ul><p>按照目前的发展，Json正在逐步取代XML成为网络数据的通用格式，所以我们重点来看Json格式的数据解析先。</p><hr><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在看如何使用Json和XML之前，我们还有些事情要做，一是准备我们要解析的数据，二是搭建一个界面来看实际效果，毕竟我们解析了数据就是要在应用中展示出来的。</p><h5 id="Json数据准备"><a href="#Json数据准备" class="headerlink" title="Json数据准备"></a>Json数据准备</h5><p>关于如何获取网络的数据在这里就不多赘述了，你只需要获得一个从网站为开发者提供的API接口中获得我们想要的url就好了。我这里调用了豆瓣电影的API，随便选了在豆瓣电影首页的电影——《前任2：备胎反击战》，来看看豆瓣对这部电影的描述，由于标签太多，我这里只打算从中获取电影名称，体裁和剧情简介三部分打印出来。</p><p>我们可以先提前在浏览器中打开看一下这个待会我们将要得到的东西：</p><p><img src="http://image.dapaner.top/Snip20151109_18.png"></p><p>是不是很乱。。。没错，网站返回的东西虽然看上去好像有点规律，但是还是难以辨别，这里不用担心，我们可以使用一个叫做<a href="http://www.bejson.com/">Json校验格式化工具</a>的东西来优化一下它的显示，这里有一个在线的。我们把网站返回给我们的数据copy到这里，点击校验，如果没有什么问题的话，为了方便展示，我把它copy到了Sublime中，我们看一下结果你会发现它变成了下面这个样子，这样看起来就舒服多了，我们也可以非常清楚地看到每一对“Key——Velue”对，以及每个Velue的类型，弄清楚了，待会儿方便我们查询和显示。</p><p><img src="http://image.dapaner.top/Snip20151111_24.png"></p><p>找到了目标，下一步我们先做个界面的模子出来，展示我们解析过的数据。大概就是下面这个样子，点击不同的按钮，可以以不同的方式解析获得的数据并在TextView中打印。</p><p><img src="http://image.dapaner.top/Snip20151109_15.png"></p><p>界面搭好之后不要忘了关联到代码。</p><p><img src="http://image.dapaner.top/Snip20151109_16.png"></p><h5 id="XML数据准备"><a href="#XML数据准备" class="headerlink" title="XML数据准备"></a>XML数据准备</h5><p>我们在项目中新建一个xml文件，编写其中的内容，待会儿解析内容并打印到TextView。</p><p><img src="http://image.dapaner.top/Snip20151110_21.png"></p><p>XML内容为Person，有几个学生的信息，包括学号，姓名，性别和年龄，一会儿根据这些创建模型。</p><p><img src="http://image.dapaner.top/Snip20151111_26.png"></p><hr><h4 id="NSJSONSerialization"><a href="#NSJSONSerialization" class="headerlink" title="NSJSONSerialization"></a>NSJSONSerialization</h4><p>接下来就正式开始。苹果官方给出的解析方式是性能最优越的，虽然用起来稍显复杂。</p><p>首先我们在上面已经有了我希望得到的信息的网站的API给我们的URL，在OC中，我要加载一个NSURL对象，来向网站提交一个Request。到这里需要特别注意了，iOS9的时代已经来临，我们先前在旧版本中使用的某些类或者方法都已经被苹果官方弃用了。刚刚我们向网站提交了一个Request，在以往，我们是通过NSURLConnection中的sendSynchronousRequest方法来接受网站返回的Response的，但是在iOS9中，它已经不再使用了。从官方文档中，我们追根溯源，找到了它的替代品——NSURLSession类。这个类是iOS7中新的网络接口，苹果力推之，并且现在用它完全替代了NSURLConnection。关于它的具体用法，还是蛮简单的，直接上代码（ViewController.m文件）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (retain, nonatomic) IBOutlet UITextView *textView;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *dic;</span><br><span class="line">@property (nonatomic,strong) NSString *text;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (IBAction)NSJson:(UIButton *)sender &#123;</span><br><span class="line">    //GCD异步实现</span><br><span class="line">    dispatch_queue_t q1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(q1, ^&#123;</span><br><span class="line"></span><br><span class="line">        //加载一个NSURL对象</span><br><span class="line">        NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://api.douban.com/v2/movie/subject/25881786&quot;]];</span><br><span class="line"></span><br><span class="line">        //使用NSURLSession获取网络返回的Json并处理</span><br><span class="line">        NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">        NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error)&#123;</span><br><span class="line"></span><br><span class="line">            //从网络返回了Json数据，我们调用NSJSONSerialization解析它，将JSON数据转换为Foundation对象（这里是一个字典）</span><br><span class="line">            self.dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];</span><br><span class="line"></span><br><span class="line">            NSString *title = [self.dic objectForKey:@&quot;original_title&quot;];</span><br><span class="line">            NSMutableArray *genresArray = [self.dic objectForKey:@&quot;genres&quot;];</span><br><span class="line">            NSString *genres = [NSString stringWithFormat:@&quot;%@/%@&quot;, [genresArray objectAtIndex:0], [genresArray objectAtIndex:1]];</span><br><span class="line">            NSString *summary = [self.dic objectForKey:@&quot;summary&quot;];</span><br><span class="line"></span><br><span class="line">            self.text = [NSString stringWithFormat:@&quot;电影名称：\n%@\n体裁：\n%@\n剧情简介：\n%@&quot;, title, genres, summary];</span><br><span class="line"></span><br><span class="line">            //更新UI操作需要在主线程</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                self.textView.text = self.text;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        //调用任务</span><br><span class="line">        [task resume];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是要再提一下，因为涉及到了网络请求，我们在这里用了一点关于使用GCD实现多线程的内容，以后再专门介绍吧。我们运行程序，点击NSJSONSerialization按钮，就看到我们要的内容啦！</p><p><img src="http://image.dapaner.top/Simulator%20Screen%20Shot%202015%E5%B9%B411%E6%9C%8811%E6%97%A5%20%E4%B8%8A%E5%8D%881.20.57.png"></p><h4 id="SBJson"><a href="#SBJson" class="headerlink" title="SBJson"></a>SBJson</h4><p>事实上上面的解析过程还是挺复杂的，主要是牵扯到了NSURLSession的使用。那接下来来看看一些第三方Json解析库的使用。SBJson用起来就简单多了。首先我们去下载这个类库，Github啊，CSDN啊，51啊哪里的任何一个地方都有，很好找。下载下来后导入我们的项目就可以直接运行了。有些第三方类库由于年代久远可能是不支持ARC的，SBJson还好，下面那个JsonKit可就不这么和谐了，这个待会再讲。我们这次点击第二个按钮来实现它。为了以示区分，这次我换了一部电影，来看看《移动迷宫2 Maze Runner: The Scorch Trials》吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//上面先导入包：</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;SBJson.h&quot;</span><br><span class="line"></span><br><span class="line">//实现：</span><br><span class="line">- (IBAction)SBJson:(UIButton *)sender &#123;</span><br><span class="line">    //GCD异步实现</span><br><span class="line">    dispatch_queue_t q1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(q1, ^&#123;</span><br><span class="line"></span><br><span class="line">        //还是先获取url</span><br><span class="line">        NSURL *url = [NSURL URLWithString:@&quot;https://api.douban.com/v2/movie/subject/25995508&quot;];</span><br><span class="line">        //返回上面url的内容，格式为Json放在了字符串里</span><br><span class="line">        NSString *jsonString = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">        //实例化SBJson对象，将Json格式字符串解析，转化为字典。</span><br><span class="line">        SBJsonParser *parser = [[SBJsonParser alloc] init];</span><br><span class="line">        self.dic = [parser objectWithString:jsonString error:nil];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        NSString *title = [self.dic objectForKey:@&quot;original_title&quot;];</span><br><span class="line">        NSMutableArray *genresArray = [self.dic objectForKey:@&quot;genres&quot;];</span><br><span class="line">        NSString *genres = [NSString stringWithFormat:@&quot;%@/%@&quot;, [genresArray objectAtIndex:0], [genresArray objectAtIndex:1]];</span><br><span class="line">        NSString *summary = [self.dic objectForKey:@&quot;summary&quot;];</span><br><span class="line">        self.text = [NSString stringWithFormat:@&quot;电影名称：\n%@\n体裁：\n%@\n剧情简介：\n%@&quot;, title, genres, summary];</span><br><span class="line"></span><br><span class="line">        //更新UI操作需要在主线程</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            self.textView.text = self.text;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看剧情好像很不错呢，打算去看一下~~</p><p><img src="http://image.dapaner.top/Simulator%20Screen%20Shot%202015%E5%B9%B411%E6%9C%8811%E6%97%A5%20%E4%B8%8A%E5%8D%881.21.01.png"></p><h4 id="JsonKit"><a href="#JsonKit" class="headerlink" title="JsonKit"></a>JsonKit</h4><p>事实上，它虽然不支持ARC,但JsonKit是在性能上仅次于苹果原生解析器的第三方类库。我们在导入它的包以后编译会出现一大堆报错，这时候不用慌，我们会发现大部分是ARC的问题，解决方法也挺简单，我们进入项目的Target，找到Build Phases里面的Compile Sources，接着找我们的问题源头JsonKit.m，双击更改它的Compiler Flags标签为“-fno-objc-arc”，再次编译，就好啦~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//上面先导入包：</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;JsonKit.h&quot;</span><br><span class="line"></span><br><span class="line">//实现</span><br><span class="line">- (IBAction)JsonKit:(UIButton *)sender &#123;</span><br><span class="line">    //GCD异步实现</span><br><span class="line">    dispatch_queue_t q1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(q1, ^&#123;</span><br><span class="line"></span><br><span class="line">        //还是先获取url</span><br><span class="line">        NSURL *url = [NSURL URLWithString:@&quot;https://api.douban.com/v2/movie/subject/26279433&quot;];</span><br><span class="line">        NSString *jsonString = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">        //代码越来越简单了有木有！！就一个方法搞定~</span><br><span class="line">        self.dic = [jsonString objectFromJSONStringWithParseOptions:JKParseOptionLooseUnicode];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        NSString *title = [self.dic objectForKey:@&quot;original_title&quot;];</span><br><span class="line">        NSMutableArray *genresArray = [self.dic objectForKey:@&quot;genres&quot;];</span><br><span class="line">        NSString *genres = [NSString stringWithFormat:@&quot;%@/%@&quot;, [genresArray objectAtIndex:0], [genresArray objectAtIndex:1]];</span><br><span class="line">        NSString *summary = [self.dic objectForKey:@&quot;summary&quot;];</span><br><span class="line">        self.text = [NSString stringWithFormat:@&quot;电影名称：\n%@\n体裁：\n%@\n剧情简介：\n%@&quot;, title, genres, summary];</span><br><span class="line"></span><br><span class="line">        //更新UI操作需要在主线程</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            self.textView.text = self.text;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们只用了一个方法，但是这可不代表JsonKit类库里就只有这一个解析的方法，我们可以去看看它的源码来找寻一番。一般来讲，如果json是“单层”的，即value都是字符串、数字，可以使用objectFromJSONString方法，这个也比较简单。如果json有嵌套，即value里有array、object，如果再使用objectFromJSONString，程序可能会报错，这时我们最好使用objectFromJSONStringWithParseOptions也就是我代码里使用的这个方法，因为电影体裁的Value是数组类型的。</p><p>这部电影叫《剩者为王》，好可怕。。。</p><p><img src="http://image.dapaner.top/Simulator%20Screen%20Shot%202015%E5%B9%B411%E6%9C%8811%E6%97%A5%20%E4%B8%8A%E5%8D%881.21.05.png"></p><h4 id="TouchJson"><a href="#TouchJson" class="headerlink" title="TouchJson"></a>TouchJson</h4><p>来看看最后一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//导入包：</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;CJSONSerializer.h&quot;</span><br><span class="line">#import &quot;CJSONDeserializer.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">- (IBAction)TouchJson:(UIButton *)sender &#123;</span><br><span class="line">    //GCD异步实现</span><br><span class="line">    dispatch_queue_t q1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(q1, ^&#123;</span><br><span class="line"></span><br><span class="line">        //还是先获取url</span><br><span class="line">        NSURL *url = [NSURL URLWithString:@&quot;https://api.douban.com/v2/movie/subject/22265299&quot;];</span><br><span class="line">        NSString *jsonString = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">        //还是一句话的事儿</span><br><span class="line">        self.dic = [[CJSONDeserializer deserializer] deserialize:[jsonString dataUsingEncoding:NSUTF8StringEncoding] error:nil];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        NSString *title = [self.dic objectForKey:@&quot;original_title&quot;];</span><br><span class="line">        NSMutableArray *genresArray = [self.dic objectForKey:@&quot;genres&quot;];</span><br><span class="line">        NSString *genres = [NSString stringWithFormat:@&quot;%@/%@&quot;, [genresArray objectAtIndex:0], [genresArray objectAtIndex:1]];</span><br><span class="line">        NSString *summary = [self.dic objectForKey:@&quot;summary&quot;];</span><br><span class="line">        self.text = [NSString stringWithFormat:@&quot;电影名称：\n%@\n体裁：\n%@\n剧情简介：\n%@&quot;, title, genres, summary];</span><br><span class="line"></span><br><span class="line">        //更新UI操作需要在主线程</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            self.textView.text = self.text;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《绝命海拔 Everest》,冒险类电影，本人不是很感冒，据说是根据真实事件改编的。</p><p><img src="http://image.dapaner.top/Simulator%20Screen%20Shot%202015%E5%B9%B411%E6%9C%8811%E6%97%A5%20%E4%B8%8A%E5%8D%881.21.10.png"></p><h4 id="Json解析总结"><a href="#Json解析总结" class="headerlink" title="Json解析总结"></a>Json解析总结</h4><p>呐，上述四种方式已经很清楚了，从代码量上来看，除了那些废话，原生的解析类库是实现起来最复杂的，其他三种倒是挺简单，通过封装，只对外提供一个简单地接口调用就能实现解析功能，性能上都还可以接受。不过从我亲身提回来讲，觉得JsonKit是里面最快的，可能是代码写的不够好，原生的解析方式如果好好优化一下的话应该是性能最好的。在实际的使用过程中选择一种方式就好。</p><h4 id="NSXMLParse"><a href="#NSXMLParse" class="headerlink" title="NSXMLParse"></a>NSXMLParse</h4><p>关于XML，有两种解析方式，分别是SAX（Simple API for XML，基于事件驱动的解析方式，逐行解析数据，采用协议回调机制）和DOM（Document Object Model ，文档对象模型。解析时需要将XML文件整体读入，并且将XML结构化成树状，使用时再通过树状结构读取相关数据，查找特定节点，然后对节点进行读或写）。苹果官方原生的NSXMLParse类库采用第一种方式，即SAX方式解析XML，它基于事件通知的模式，一边读取文档一边解析数据，不用等待文档全部读入以后再解析，所以如果你正打印解析的数据，而解析过程中间出现了错误，那么在错误节点之间的数据会正常打印，错误后面的数据不会被打印。解析过程由NSXMLParserDelegate协议方法回调。</p><blockquote><p>插句题外话先，我在写这种方式解析XML数据的Demo时折腾了整整一天，说起来都有些不好意思了。程序运行的时候一直出现不能完成解析的情况，各种查各种试，真的是整了整整一天的时间。就在崩溃的边缘的时候，我竟然发现在我自己写XML文件时少写了一个“&#x2F;。。。瞬间感觉整个世界都崩塌了。所以特地记下来警示自己也顺便给大家提个醒，在这种低级失误上浪费整整一天的时间，要多不值有多不值。谨记，谨记。</p></blockquote><p>我们遵循MVC，首先我们创建模型，新建一个person类，存放XML文件中描述的person属性。再来一个解析XML文件的工具类XMLUtil，我们在里面实现文件的获取，代理方法的实现。</p><p>先来看这两个类的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//person.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface person : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *pid;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *sex;</span><br><span class="line">@property (nonatomic, copy) NSString *age;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">//XMLUtil.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;person.h&quot;</span><br><span class="line">//声明代理</span><br><span class="line">@interface XMLUtil : NSObject&lt;NSXMLParserDelegate&gt;</span><br><span class="line">//添加属性</span><br><span class="line">@property (nonatomic, strong) NSXMLParser *par;</span><br><span class="line">@property (nonatomic, strong) person *person;</span><br><span class="line">//存放每个person</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *list;</span><br><span class="line">//标记当前标签，以索引找到XML文件内容</span><br><span class="line">@property (nonatomic, copy) NSString *currentElement;</span><br><span class="line"></span><br><span class="line">//声明parse方法，通过它实现解析</span><br><span class="line">-(void)parse;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//XMLUtil.m</span><br><span class="line"></span><br><span class="line">#import &quot;XMLUtil.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XMLUtil</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        //获取事先准备好的XML文件</span><br><span class="line">        NSBundle *b = [NSBundle mainBundle];</span><br><span class="line">        NSString *path = [b pathForResource:@&quot;test&quot; ofType:@&quot;.xml&quot;];</span><br><span class="line">        NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">        self.par = [[NSXMLParser alloc]initWithData:data];</span><br><span class="line">        //添加代理</span><br><span class="line">        self.par.delegate = self;</span><br><span class="line">        //初始化数组，存放解析后的数据</span><br><span class="line">        self.list = [NSMutableArray arrayWithCapacity:5];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//几个代理方法的实现，是按逻辑上的顺序排列的，但实际调用过程中中间三个可能因为循环等问题乱掉顺序</span><br><span class="line">//开始解析</span><br><span class="line">- (void)parserDidStartDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    NSLog(@&quot;parserDidStartDocument...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//准备节点</span><br><span class="line">- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(nullable NSString *)namespaceURI qualifiedName:(nullable NSString *)qName attributes:(NSDictionary&lt;NSString *, NSString *&gt; *)attributeDict&#123;</span><br><span class="line"></span><br><span class="line">    self.currentElement = elementName;</span><br><span class="line"></span><br><span class="line">    if ([self.currentElement isEqualToString:@&quot;student&quot;])&#123;</span><br><span class="line">        self.person = [[person alloc]init];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//获取节点内容</span><br><span class="line">- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123;</span><br><span class="line"></span><br><span class="line">    if ([self.currentElement isEqualToString:@&quot;pid&quot;]) &#123;</span><br><span class="line"></span><br><span class="line">        [self.person setPid:string];</span><br><span class="line">    &#125;else if ([self.currentElement isEqualToString:@&quot;name&quot;])&#123;</span><br><span class="line">        [self.person setName:string];</span><br><span class="line">    &#125;else if ([self.currentElement isEqualToString:@&quot;sex&quot;])&#123;</span><br><span class="line">        [self.person setSex:string];</span><br><span class="line">    &#125;else if ([self.currentElement isEqualToString:@&quot;age&quot;])&#123;</span><br><span class="line"></span><br><span class="line">        [self.person setAge:string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解析完一个节点</span><br><span class="line">- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(nullable NSString *)namespaceURI qualifiedName:(nullable NSString *)qName&#123;</span><br><span class="line"></span><br><span class="line">    if ([elementName isEqualToString:@&quot;student&quot;]) &#123;</span><br><span class="line">        [self.list addObject:self.person];</span><br><span class="line">    &#125;</span><br><span class="line">    self.currentElement = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解析结束</span><br><span class="line">- (void)parserDidEndDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    NSLog(@&quot;parserDidEndDocument...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//外部调用接口</span><br><span class="line">-(void)parse&#123;</span><br><span class="line">    [self.par parse];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OK，总算是大功告成，如果对代理的使用比较熟悉的话，这部分内容其实还蛮简单的。如果被代码转来转去弄晕了的话可以在每个block的最后都加一个打印输出，做好标记，你就能弄懂程序的执行顺序了。</p><p>我们点击NSXMLParse，有了！</p><p><img src="http://image.dapaner.top/Simulator%20Screen%20Shot%202015%E5%B9%B411%E6%9C%8811%E6%97%A5%20%E4%B8%8A%E5%8D%881.21.13.png"></p><h4 id="GDataXML"><a href="#GDataXML" class="headerlink" title="GDataXML"></a>GDataXML</h4><p>来看GDataXML，它是一种DOM方式的解析类库。DOM实现的原理是把整个xml文档一次性读出，放在一个树型结构里。在需要的时候，查找特定节点，然后对节点进行读或写。</p><p>在使用之前呢，我们还是先从网上下载GDataXML包，里面两个文件GDataXMLNode.h和GDataXMLNode.m导入到项目中来，编译，发现报错了，这是因为GDataXML是依赖libmxl2的，我们要去项目的Target中做一些设置。</p><ul><li>找到项目的Tarfet，进入Build Phases里面的Link Binary With Libraries,点击“加号”，搜索libxml，把出现的包添加进去，这里最新版的XCode7和iOS9中，是libxml.2.2.tbd。</li><li>再来到Build Settings，我们可以搜索一下，找到Header Search Paths，添加路径“&#x2F;usr&#x2F;include&#x2F;libxml2”。</li><li>再找到Other Link Flags，添加“-libxml2“</li><li>还有就是如果你下载的GDataXML是不支持ARC的，那么你就要像上面那样去添加“-fno-objc-arc”，这个视你下载的GDataXML包版本而定。</li></ul><p>再次编译，就顺利通过了。</p><p>接下来看看我们怎么用这个东西。贴代码之前我真的想说一句，比起苹果原生的类库，这些开源的第三方类库真的在用起来的时候不知道有多舒服，懒人必备啊。在实际的开发中可以为我们节省很多的时间与精力，但是还是要搞懂人家原生的东西，这样才叫学会了么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//ViewController.m</span><br><span class="line"></span><br><span class="line">- (IBAction)GDataXML:(id)sender &#123;</span><br><span class="line"></span><br><span class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSData *data = [[NSData alloc]initWithContentsOfFile:path];</span><br><span class="line">    //对象初始化</span><br><span class="line">    GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data error:nil];</span><br><span class="line">    //获取根节点</span><br><span class="line">    GDataXMLElement *rootElement = [doc rootElement];</span><br><span class="line">    //获取其他节点</span><br><span class="line">    NSArray *students = [rootElement elementsForName:@&quot;student&quot;];</span><br><span class="line">    //初始化可变数组，用来显示到textView</span><br><span class="line">    self.GDatatext = [[NSMutableString alloc]initWithString:@&quot;&quot;];</span><br><span class="line">    for (GDataXMLElement *student in students) &#123;</span><br><span class="line">        //获取节点属性</span><br><span class="line">        GDataXMLElement *pidElement = [[student elementsForName:@&quot;pid&quot;] objectAtIndex:0];</span><br><span class="line">        NSString *pid = [pidElement stringValue];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        GDataXMLElement *nameElement = [[student elementsForName:@&quot;name&quot;] objectAtIndex:0];</span><br><span class="line">        NSString *name = [nameElement stringValue];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        GDataXMLElement *sexElement = [[student elementsForName:@&quot;sex&quot;] objectAtIndex:0];</span><br><span class="line">        NSString *sex = [sexElement stringValue];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        GDataXMLElement *ageElement = [[student elementsForName:@&quot;age&quot;] objectAtIndex:0];</span><br><span class="line">        NSString *age = [ageElement stringValue];</span><br><span class="line"></span><br><span class="line">        //调整一下姿势，添加到可变长字符串~~</span><br><span class="line">        NSString *t = [NSString stringWithFormat:@&quot;学号：%@ 姓名：%@ 性别：%@ 年龄：%@\n&quot;, pid, name, sex, age];</span><br><span class="line">        [self.GDatatext appendString:t];</span><br><span class="line">    &#125;</span><br><span class="line">    self.textView.text = self.GDatatext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就一段，是不是看起来非常的舒服呢！</p><p>跑一下，跟我们刚才使用的NSXMLParse是不是一样呢？</p><p><img src="http://image.dapaner.top/Simulator%20Screen%20Shot%202015%E5%B9%B411%E6%9C%8811%E6%97%A5%20%E4%B8%8A%E5%8D%881.21.13.png"></p><p>哈，搞定！</p><h4 id="XML解析总结"><a href="#XML解析总结" class="headerlink" title="XML解析总结"></a>XML解析总结</h4><p>上述两种解析用到的类库分别代表了两种典型的XML数据解析方式，SAX和DOM，各有优势，比如在应对比较大数据量的XML文件时，后者由于需要先读取整个文档，性能和速度上就必然不及前者了。</p><p>其实现在在实际应用中XML已经越来越少了，但是说起iOS中的网络编程，就免不了和XML格式的数据打交道。还有就是，我们在这里仅仅介绍了两种常用的XML解析方式，如同解析Json数据一样，解析XML文件也有很多种方法，除了上述两种，还有比如像TBXML, TouchXML, KissXML, TinyXML等等，具体的使用方法可以去Github上找，都有使用方法的说明的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;除了XML和Json，文中还涉及到的一些知识：第三方类库的使用，获取本地文件内容，网站API使用，GCD多线程编程，不做详细介绍，在代码出现的地方会注明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先安利一波：&lt;/p&gt;
&lt;p&gt;&lt;a hre
      
    
    </summary>
    
      <category term="iOS" scheme="http://dapaner.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://dapaner.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UI组件学习（个人整理）</title>
    <link href="http://dapaner.top/2015/11/04/iOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94UI%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%86%EF%BC%89/"/>
    <id>http://dapaner.top/2015/11/04/iOS开发——UI组件学习（个人整理）/</id>
    <published>2015-11-04T09:42:19.000Z</published>
    <updated>2019-06-16T07:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近把iOS里的UI组件重新整理了一遍，简单来看一下常用的组件以及它们的实现。其实现在这些组件都可以通过Storyboard很快的生成，只是要向这些组件能够变得生动起来并且赋予它们更具生命力的事件，还是需要一番功夫的。</p><hr><h4 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h4><p>这儿有一篇教程，挺全的，可以参考下：<a href="http://www.cnblogs.com/chen1987lei/archive/2011/09/09/2172757.html">http://www.cnblogs.com/chen1987lei/archive/2011/09/09/2172757.html</a></p><p>这个就不多说了，对照官方的文档也可以更多的去学习。插一句题外话，在学这些组件的时候，最令人头疼的不是你搞不定一个组件的某个属性或者方法，而是你压根儿不知道有这个东西。所以在学习这些组件的时候最好的方式还是通过官方文档，虽然已开始可能有些困难，但是硬着头皮去啃，就一定会有悟道的那一天。建议有问题先去看文档，如果实在不行再去Google啊，Stack Overflow啊神马的。</p><h4 id="UIAlertController"><a href="#UIAlertController" class="headerlink" title="UIAlertController"></a>UIAlertController</h4><p>弹出式的提示框。现在市面上的书籍包括网上的一些资料都还停留在iOS8之前的时代，那个时候的弹出框是一个叫做UIAlertView的东西，但是现在，在XCode7和iOS9的时代，你会发现这个东西被弃用了。苹果自iOS8开始，废除了UIAlertView而改用UIAlertController来控制提示框。</p><p>来看看UIAlertController的实现吧，下面这个程序是我在练习UITableView时的代码，实现了一个类似与通讯录的东西，我们抓住主要矛盾，来看点击某一行cell后，弹出的消息提示框是怎么实现的。以下代码在ViewController.m中实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//创建提示框窗口</span><br><span class="line"></span><br><span class="line">UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;System Info&quot; message:[contact getName] preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">//实例化取消按钮  </span><br><span class="line">UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;Cancel&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123;</span><br><span class="line">//点击取消按钮后控制台打印语句。</span><br><span class="line">NSLog(@&quot;The \&quot;Okay/Cancel\&quot; alert&#x27;s cancel action occured.&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">//实例化确定按钮    </span><br><span class="line">UIAlertAction *otherAction = [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) &#123;</span><br><span class="line">NSLog(@&quot;The \&quot;Okay/Cancel\&quot; alert&#x27;s other action occured.&quot;);</span><br><span class="line">//下面这段代码不用管它，简单点讲就是获取当前行的一个字符串。</span><br><span class="line">    UITextField *textfield = alertController.textFields[0];</span><br><span class="line">    KCContactGroup *group = _contacts[_selectedIndexPath.section];</span><br><span class="line">    KCContact *contact = group.contacts[_selectedIndexPath.row];</span><br><span class="line">    contact.phoneNumber = textfield.text;</span><br><span class="line">    NSArray *indexPaths = @[_selectedIndexPath];</span><br><span class="line">    [_tableview reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationLeft];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">//向弹出框中添加按钮和文本框</span><br><span class="line">[alertController addAction:cancelAction];</span><br><span class="line">[alertController addAction:otherAction];</span><br><span class="line">[alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) &#123;</span><br><span class="line">    // 可以在这里对textfield进行定制，例如改变背景色等</span><br><span class="line">    textField.text = contact.phoneNumber;</span><br><span class="line">&#125;];</span><br><span class="line">//将提示框弹出</span><br><span class="line">[self presentViewController:alertController animated:YES completion:nil];</span><br></pre></td></tr></table></figure><p>实现了大概就是这个样子，文本框里的东西是从cell里面提取的。</p><p><img src="http://image.dapaner.top/Snip20151104_4.png"></p><p>这里还有一句题外话要讲。网上是没有任何关于最新的UIAlertController的使用教程的，我自己用了整整一个下午看官方文档一步一步调试才实现了这个恼人的提示框。官方的文档真的是个好东西，越用越强大！！</p><h4 id="UISegmentedControl"><a href="#UISegmentedControl" class="headerlink" title="UISegmentedControl"></a>UISegmentedControl</h4><p>分段控件，就是一栏按钮集成在一排里。很简单，就像Button一样。这个样子的：</p><p><img src="http://image.dapaner.top/Snip20151104_5.png"></p><h4 id="UISwtich"><a href="#UISwtich" class="headerlink" title="UISwtich"></a>UISwtich</h4><p>按钮控件，手机里开飞行模式的那个东西。通过Storyboard可以很快很方便的建立，不要忘了关联起来就好。</p><p>这里简单讲一下它的纯代码实现，其实包括上面的UISegmentedControl，还有下面的一些简单控件它们手写实现的方法都是一样的。截张图给大家说明一下就好了，都是一样的，后面的类似的控件也不多啰嗦了。</p><p><img src="/"></p><h4 id="UISlider"><a href="#UISlider" class="headerlink" title="UISlider"></a>UISlider</h4><p>进度条型的选择控件，对应数值，可以进行设置音量等操作，根据官方文档可以看到很多关于它的设置，基本实现同上。</p><h4 id="UIPageControl"><a href="#UIPageControl" class="headerlink" title="UIPageControl"></a>UIPageControl</h4><p>这是个好东西。</p><p>这是个好东西。</p><p>这是个好东西。</p><p>重要的事情说三遍。个人认为，它虽然很小，但绝对逼格够高，搭配UIScrollView，绝对让你的界面高端起来。</p><p>关于这个的代码不小心被我删掉了，没法给大家展示，不过过几天我会用这个做一个APP的欢迎界面，到时候再展示咯。</p><h4 id="UITextField"><a href="#UITextField" class="headerlink" title="UITextField"></a>UITextField</h4><p>简单控件，可以参考先前的传值操作（传送门：<a href="http://xdgcc.github.io/2015/10/19/iOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8BDelegate/">iOS开发——从一道题看Delegate</a>），基本上把这个的用法实现的差不多了，要想更多地设置它————官方文档见。</p><h4 id="UIDatePicker"><a href="#UIDatePicker" class="headerlink" title="UIDatePicker"></a>UIDatePicker</h4><p>顾名思义，日期选择控件。实现同上。</p><h4 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h4><p>有的时候呢，我们的照片，或者图片会很大，而允许我们输出的窗口却不够大，那么我们就需要这个家伙来帮忙了，它可以让一张图片在一个视图里滚动展示，效果类似于。。。做B超？（天，怎么会有这种脑洞大开的比喻）</p><p>大概就是这样整的：<br><img src="http://image.dapaner.top/Snip20151104_9.png"></p><h4 id="UITextView"><a href="#UITextView" class="headerlink" title="UITextView"></a>UITextView</h4><p>还是一个可编辑文本框，与先前的UITextField不同的是，这个可以显示更多行的内容，还可以对他进行编辑的监控，通过代理方法，我们可以获取该文本框中的内容，在实际的应用中，发布什么长微博啊，文本啊，都能用到它。</p><p>这里实现没什么好说的，主要来看看它的几个代理方法：</p><p><img src="http://image.dapaner.top/Snip20151104_10.png"></p><h4 id="UIToolbar"><a href="#UIToolbar" class="headerlink" title="UIToolbar"></a>UIToolbar</h4><p>开发中经常会用到的控件之一，实现起来也很简单，与此同时我们还要知道 UIBarButtonItem 和 Fixed Space Bar Button Item，这两个小东西是在Bar上的按钮和间距，都被对象化了。</p><p>来看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">//声明</span><br><span class="line">@property (nonatomic, strong) UIToolbar *mytoolbar;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //实例化</span><br><span class="line">    self.mytoolbar = [[UIToolbar alloc]initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, 30)];</span><br><span class="line">    //添加到视图</span><br><span class="line">    [self.view addSubview:self.mytoolbar];</span><br><span class="line">    //选择风格，这里我们选择黑色风格</span><br><span class="line">    self.mytoolbar.barStyle = UIBarStyleBlack;</span><br><span class="line">    //添加按钮和按钮之间的间距，这些都被对象化了，按钮是可以实现方法的</span><br><span class="line">    UIBarButtonItem *item1 = [[UIBarButtonItem alloc]initWithTitle:@&quot;hello&quot; style:UIBarButtonItemStylePlain target:self action:@selector(sayhello)];</span><br><span class="line">    UIBarButtonItem *fixed = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];</span><br><span class="line"></span><br><span class="line">    UIBarButtonItem *item2 = [[UIBarButtonItem alloc]initWithTitle:@&quot;bye&quot; style:UIBarButtonItemStylePlain target:self action:@selector(saybye)];</span><br><span class="line">    //实例化的UIToolbar里面有items属性，是一个数组，用来存放我们要加上去的按钮</span><br><span class="line">    self.mytoolbar.items = @[item1, fixed, item2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//点击item要实现的方法，输出hello或者bye</span><br><span class="line">- (IBAction)sayhello&#123;</span><br><span class="line">    NSLog(@&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saybye&#123;</span><br><span class="line">    NSLog(@&quot;bye&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="UIPickerView"><a href="#UIPickerView" class="headerlink" title="UIPickerView"></a>UIPickerView</h4><p>与前面的时间选择类似，只不过这个你可以自己设置内容。</p><h4 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h4><p>BOOM!</p><p>强大，异常强大。不多说，我推荐看<a href="http://www.cnblogs.com/kenshincui/p/3931948.html">iOS开发系列–UITableView全面解析</a>这篇文章，写得很棒。</p><p>我自己也把大部分的学习时间用在了它的学习上，至今为止我觉得我还没能真正做到熟练地使用它，等以后成熟了，再写吧。</p><h4 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a>UICollectionView</h4><p>又是一个庞大的家伙，在很多壁纸类APP中我们可以看到它的影子。</p><p>关于它的实现，我总结为以下几步：</p><ul><li>.h文件声明代理和数据源</li><li>.m文件具体实现<ul><li>声明UICollectionView</li><li>实例化，包括设置大小，位置，颜色等等</li><li>加载代理和数据源到实例化的view</li><li>注册cell（这里需要）</li><li>将实例化的UICollectionView加入到View中</li><li>实现数据源方法（包括必须实现的和选择实现的）</li><li>实现代理方法（包括必须实现的和选择实现的）</li></ul></li></ul><p>关于数据源方法和代理方法，在这里需要特别说明一下，我们还是会出现不知道这个数据源或者代理中到底有什么的困惑，我们要command进去这些代理或者数据源去发现和寻找，文档还是我们学习的最终归宿。</p><p>按照上面的步骤，实现代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) UICollectionView *collectionView;</span><br><span class="line">@end</span><br><span class="line">static NSString *cid = @&quot;cid&quot;;</span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    UICollectionViewFlowLayout *flowlayout = [[UICollectionViewFlowLayout alloc]init];</span><br><span class="line"></span><br><span class="line">    CGRect flame = CGRectMake(20, 40, self.view.frame.size.width-40, self.view.frame.size.height-60);</span><br><span class="line">    self.collectionView = [[UICollectionView alloc]initWithFrame:flame collectionViewLayout:flowlayout];</span><br><span class="line"></span><br><span class="line">    self.collectionView.dataSource = self;</span><br><span class="line">    self.collectionView.delegate = self;</span><br><span class="line">    [self.view addSubview:self.collectionView];</span><br><span class="line"></span><br><span class="line">    //注册cell</span><br><span class="line">    [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:cid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;</span><br><span class="line">    return 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The cell that is returned must be retrieved from a call to -dequeueReusableCellWithReuseIdentifier:forIndexPath:</span><br><span class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:cid forIndexPath:indexPath];</span><br><span class="line"></span><br><span class="line">    cell.backgroundColor = [UIColor blueColor];</span><br><span class="line"></span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section&#123;</span><br><span class="line">    return UIEdgeInsetsMake(10, 10, 10, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    return CGSizeMake(120, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">    UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];</span><br><span class="line">    cell.backgroundColor = [UIColor yellowColor];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%ld&quot;,indexPath.row);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">    UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];</span><br><span class="line">    cell.backgroundColor = [UIColor blueColor];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h4><p>接下来我们来聊聊ViewController。视图控制器在我们开发中最重要的 MVC模式 中扮演着重要的角色，作为显示和数据的调度者，它的存在决定了我们的程序到底以怎样的形式呈现在用户面前。</p><p>这个最基础的Controller就不多说了，在目前的XCode中，一般来说新建的第一个Single View就是用的这个。</p><h4 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h4><p>很重要的一个东西。导航视图控制器。说简单点它就是一个来存放视图的栈，原则上先进后出，一层一层的来管理在它里面的视图。在学习它的过程中还要掌握UINavigationBar、UINavigationitem等控件，还要熟悉几个pop、push方法。</p><p>既然是导航视图控制器，导航自然不是导的一个视图，而是管理多个视图，实现的时候有很多需要注意的地方，我们一步一步的来看。</p><p>首先新建一个工程，我们要纯手写代码来搞定之。</p><h5 id="第一步，建立我们需要管理的多个视图。"><a href="#第一步，建立我们需要管理的多个视图。" class="headerlink" title="第一步，建立我们需要管理的多个视图。"></a>第一步，建立我们需要管理的多个视图。</h5><p>“command+N”新建Cocoa Touch Class，命名为myViewController，Subclass of选择为UIViewController，重复四次，我们获得了四个试图控制器，也就是四个视图，接下来我们将用导航视图控制器来管理它们。</p><h5 id="第二步，初始界面设置"><a href="#第二步，初始界面设置" class="headerlink" title="第二步，初始界面设置"></a>第二步，初始界面设置</h5><p>在这里，我们需要来到AppDelegate.m文件，来配置初始界面，自定义- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 方法。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line"></span><br><span class="line">    //获取屏幕大小</span><br><span class="line">    UIScreen *screen = [UIScreen mainScreen];</span><br><span class="line">    //初始化窗口</span><br><span class="line">    self.window = [[UIWindow alloc]initWithFrame:screen.bounds];</span><br><span class="line">    //将视图1设置为初始视图</span><br><span class="line">    myViewController1 *vc1 = [[myViewController1 alloc]init];</span><br><span class="line">    //来个背景颜色区分一下</span><br><span class="line">    vc1.view.backgroundColor = [UIColor blueColor];</span><br><span class="line">    //实例化导航视图控制器并添加视图1进来</span><br><span class="line">    UINavigationController *nc = [[UINavigationController alloc]initWithRootViewController:vc1];</span><br><span class="line">    //将导航视图控制器设置为窗口根视图</span><br><span class="line">    self.window.rootViewController = nc;</span><br><span class="line">    //设置窗口可见</span><br><span class="line">    [self.window makeKeyAndVisible];</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三步，配置各个视图"><a href="#第三步，配置各个视图" class="headerlink" title="第三步，配置各个视图"></a>第三步，配置各个视图</h5><p>我们要在第一个视图中实例化第二个视图，并通过某种方式，使用UINavigationController跳转到第二个视图；在第二个视图中实例化第三个视图，以此类推直到最后一个视图。当然，我们也可以选择直接跳到某个你想要去的视图，比如从第四个视图跳到第一个或者第二个。</p><p>我们现在视图一中添加一个按钮，添加一个点击按钮的事件，注意，我们就是通过这个事件方法来实现页面的跳转的，myViewController1.m代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;myViewController1.h&quot;</span><br><span class="line">#import &quot;myViewController2.h&quot;</span><br><span class="line">@interface myViewController1 ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation myViewController1</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //设置视图二样式，添加一个按钮，点击触发事件，跳转到下一页面</span><br><span class="line"></span><br><span class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];</span><br><span class="line">    [btn setTitle:@&quot;GO&quot; forState:UIControlStateNormal];</span><br><span class="line">    btn.frame = CGRectMake(160, 100, 30, 36);</span><br><span class="line">    [btn addTarget:self action:@selector(go:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:btn];</span><br><span class="line"></span><br><span class="line">    UILabel *lable = [[UILabel alloc]initWithFrame:CGRectMake(160, 160, 100, 36)];</span><br><span class="line">    lable.text = @&quot;第一页&quot;;</span><br><span class="line">    [self.view addSubview:lable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里才是实现页面跳转的重点！！！！</span><br><span class="line">-(IBAction)go:(id)sender&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    myViewController2 *vc2 = [[myViewController2 alloc]init];</span><br><span class="line">    vc2.view.backgroundColor = [UIColor greenColor];</span><br><span class="line"></span><br><span class="line">    //看这里！！！！！push方法将视图一推向视图二</span><br><span class="line"></span><br><span class="line">    [self.navigationController pushViewController:vc2 animated:YES];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，我们编写myViewController2.m，myViewController3.m，myViewController4.m的代码。我们稍微修改一下myViewController4.m中的go方法，让视图四直接跳到视图二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(IBAction)go:(id)sender&#123;</span><br><span class="line"></span><br><span class="line">    //[self.navigationController popViewControllerAnimated:YES];pop方法跳回前一视图</span><br><span class="line">    //[self.navigationController popToRootViewControllerAnimated:YES];popToRoot方法直接跳回第一视图</span><br><span class="line">    NSArray *controllers = self.navigationController.viewControllers;</span><br><span class="line">    //popToViewController方法，我们可以选择要跳到的视图</span><br><span class="line">    [self.navigationController popToViewController:[controllers objectAtIndex:1] animated:YES];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UITabbarController"><a href="#UITabbarController" class="headerlink" title="UITabbarController"></a>UITabbarController</h4><p>区别于UINavigationController的顶部导航，UITabbarController是底部导航，功能上差不多，可以直接切换多个视图，典型的应用非常多，微信，QQ都是，实现起来也是类似于上面的UINavigationController。</p><p>可以参考这篇资料：<a href="http://www.cnblogs.com/wendingding/p/3775488.html">iOS开发UI篇—UITabBarController简单介绍</a></p><hr><p>简单地总结到这里，只是很简单的实现，日后通过文档再慢慢地学习更深层次的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近把iOS里的UI组件重新整理了一遍，简单来看一下常用的组件以及它们的实现。其实现在这些组件都可以通过Storyboard很快的生成，只是要向这些组件能够变得生动起来并且赋予它们更具生命力的事件，还是需要一番功夫的。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;UIButton&quot;&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://dapaner.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://dapaner.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>自定义并使用自己的ViewController</title>
    <link href="http://dapaner.top/2015/10/20/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84ViewController/"/>
    <id>http://dapaner.top/2015/10/20/自定义并使用自己的ViewController/</id>
    <published>2015-10-20T15:16:20.000Z</published>
    <updated>2019-06-22T02:23:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS6以后，在新建工程时已经没有了以前的Empty Application，往往新建的是Single View Application，而这个模板却自带了ViewController。在实际的应用中，我们往往需要自定义ViewController，要使用更易理解的命名，这时候，系统默认的这个家伙就显得有些烦人了，作为一个重度强迫症，自然是不能忍受的。但是如果只是简单地将ViewController.h和ViewController.m文件删除，然后新建自己的ViewController并使用，往往不能如人所愿，会出现各种各样的问题，抛出NSInternalInconsistencyException异常神马的。</p><p>经过各种折腾研究，总结出一套方案，解决了这个问题。</p><p>首先删除ViewController.h和ViewController.m文件。</p><p>打开 Info.plist，删除里面的Main storyboard file base name…</p><p>新建自己的ViewController文件，产生.h和.m文件（如MainViewController.h和MainViewController.m）。</p><p>编写这两个文件，实现你的要求。</p><p>向AppDelegate.m导入刚才新建并编辑过的.h文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MainViewController.h&quot;</span><br></pre></td></tr></table></figure><p>修改AppDelegate.m文件中的application方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line">self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line"></span><br><span class="line">self.window.rootViewController = [[MainViewController alloc]init];</span><br><span class="line"></span><br><span class="line">[self.window makeKeyAndVisible];</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS6以后，在新建工程时已经没有了以前的Empty Application，往往新建的是Single View Application，而这个模板却自带了ViewController。在实际的应用中，我们往往需要自定义ViewController，要使用更易理解的命名，这
      
    
    </summary>
    
      <category term="iOS" scheme="http://dapaner.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://dapaner.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>从一道题看Delegate</title>
    <link href="http://dapaner.top/2015/10/19/iOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8BDelegate/"/>
    <id>http://dapaner.top/2015/10/19/iOS开发——从一道题看Delegate/</id>
    <published>2015-10-19T11:05:51.000Z</published>
    <updated>2019-06-16T07:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>继上次通过Storyboard完成了简单地页面跳转之后，我发现了很多问题，比如从第二个页面回跳到第一个页面，并不是依照正向跳转那样简单地模仿就好，在实际运行中会发现程序报错了。这次，我们将结合一道经典的题目，完成对页面跳转、传值以及附带的相关键盘输入的问题总结。题目源自《iOS开发之美》一书，有兴趣的小伙伴可以去翻来看看，我在学习之后加入了很多自己的感悟和实际操作的情况。原题如下：</p><blockquote><p>有两个scene，分别为Scene A和Scene B。Scene A上有一个UIButton（Button A）和一个UILable（Lable A）；Scene B上有一个UITextFiled（textFiled）。当单击Scene A上的Button A时，跳转到Scene B，在Scene B的textFiled上输入文字，单击键盘的“完成”按钮，返回到Scene A，并在Scene A的Lable A上显示刚才输入的内容。</p></blockquote><p>这是一个典型的场景之间的跳转和逆向传值问题，看似简单，却暗藏杀机。我们不仅要使用Storyboard框架，还要采用Delegate模式，最后达到题目要求。</p><hr><h3 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h3><p>什么是Delegate？跟这道题目又有什么关系呢？</p><p>简单分析一下题目，主要包括Storyboard的应用，页面跳转，数据的交互，似乎跟Delegate没什么关系呢。在这里我决定先不刨根问底，留一个小悬念，在实际的解决问题的过程中去慢慢“悟”关于Delegate的一切，它是一种设计模式，并不是那么简单就能描述清楚的。</p><hr><h3 id="页面之间的数据传递"><a href="#页面之间的数据传递" class="headerlink" title="页面之间的数据传递"></a>页面之间的数据传递</h3><p>iOS提供了多种方法，来实现页面之间的数据传递：</p><ul><li>使用SharedApplication，定义一个类似全局的变量来传递</li><li>使用文件，或者使用NSUserdefault来传递</li><li>通过一个单例（SingleXX）的class来传递</li><li>通过Delegate来传递</li></ul><p>关于数据的存储方式共有五种：</p><ul><li>User Defaults</li><li>Property List（对应）</li><li>Object archives</li><li>SQLite</li><li>Core Data</li></ul><p>在本道题目当中，显然采用Delegate方式是最佳方案。</p><hr><h3 id="界面搭建"><a href="#界面搭建" class="headerlink" title="界面搭建"></a>界面搭建</h3><p>有了先前我们使用Storyboard的经验，我们先很快的对界面进行搭建。先抛开所有的segue不管，先把题目中描述的情况展现出来再说。</p><p>我们新建名为delegateSentValue的工程，在原有viewController的基础上再新建一个，同时新建名为viewController2的.h和.m文件，对它们进行关联。再向两个view中拖放组件，并且将它们关联到相应的文件。这个过程应该是很简单的，我们暂且不管需要响应事件的Button，只是将两个Lable和一个textFiled在两个.h文件中进行属性声明。完成后如下图：</p><p><img src="http://image.dapaner.top/Snip20151019_72.png"><br><img src="http://image.dapaner.top/Snip20151019_73.png"></p><p>搭建完成界面之后，我们先实现从Scene A到Scene B的跳转。通过“Ctrl+drag”操作，将Button与Scene B关联，设置为“modal”模式，然后我们选中这个Segue，将它的identifier命名为Segue_ID_AB。</p><p><img src="http://image.dapaner.top/Snip20151019_74.png"></p><p>我们可以先来运行下，这时我们可以实现通过点击按钮实现页面正向跳转的功能，点击输入框，我们可以接受键盘的输入。</p><hr><h3 id="Delegate应用"><a href="#Delegate应用" class="headerlink" title="Delegate应用"></a>Delegate应用</h3><p>我们所剩的任务还有输入内容，单击键盘上的“完成（return）”按钮，返回Scene A，并将刚才输入的内容显示在Scene A中。</p><p>对于一个Delegate应用，需要5步来完成：</p><ul><li>委托者声明一个Delegate</li><li>委托者调用Delegate内的方法</li><li>关联委托者与被委托者</li><li>被委托者遵循Delegate协议</li><li>被委托者重写Delegate内的方法</li></ul><h4 id="委托者声明一个Delegate"><a href="#委托者声明一个Delegate" class="headerlink" title="委托者声明一个Delegate"></a>委托者声明一个Delegate</h4><p>在ViewController2中，#import &lt;UIKit&#x2F;UIKit.h&gt;下，@interface前添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol ViewController2Delegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">-(void) viewController2:(ViewController2 * )sceneBVC didInputed:(NSString * )string;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在@interface中声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (weak, nonatomic) id &lt;ViewController2Delegate&gt; delegate;</span><br></pre></td></tr></table></figure><p>通过@protocol创建一个Delegate并声明。</p><p>这里需要注意的一点是，如果仅仅是按照上面的要求去添加代码，会出现“Expected a type.”的错误，原因是我们要使用ViewController2类型，而这个类型先前是没有定义过的，可是如果我们把@protocol，也就是上面三行代码移到@property下面去的时候呢，在声明中的ViewController2Delegate又出现了同样的问题。于是乎，我们需要修改一下代码的结构，我们首先创建Delegate，然后声明，最后再在@interface的后面定义Delegate内的方法，这样一来就没有问题了。最后完整的ViewController2.h的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@protocol ViewController2Delegate;</span><br><span class="line"></span><br><span class="line">@interface ViewController2 : UIViewController</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *showInformation2;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *inputInformation;</span><br><span class="line">@property (weak, nonatomic) id &lt;ViewController2Delegate&gt; delegate;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol ViewController2Delegate &lt;NSObject&gt;</span><br><span class="line">-(void) viewController:(ViewController2 *) sceneBVC didInputed:(NSString *) string;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="委托者调用Delegate内的方法"><a href="#委托者调用Delegate内的方法" class="headerlink" title="委托者调用Delegate内的方法"></a>委托者调用Delegate内的方法</h4><p>解决了上面的问题后，这一步就比较简单了，添加代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)textFieldShouldReturn:(UITextField *) textField&#123;</span><br><span class="line">    if (self.delegate) &#123;</span><br><span class="line">        //将UITextField内容传递给Delegate内的方法</span><br><span class="line">        [self.delegate viewController:self didInputed:self.inputInformation.text];</span><br><span class="line">        //让当前呈现的Scene B页面消失</span><br><span class="line">        [self.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    //让键盘消失</span><br><span class="line">    [textField resignFirstResponder];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅添加代码是远远不够的，我们还要关联，具体做法是在Storyboard中，选中ViewController2中的TextFiled控件，采用“Ctrl+drag”操作将其与ViewController2关联。</p><p><img src="http://image.dapaner.top/Snip20151019_75.png"></p><p>在Outlets中选中delegate。</p><p><img src="http://image.dapaner.top/Snip20151019_76.png"></p><p>关于让键盘消失这个问题，我会单独写篇文章说明，在这里先占个坑。</p><h4 id="关联委托者与被委托者"><a href="#关联委托者与被委托者" class="headerlink" title="关联委托者与被委托者"></a>关联委托者与被委托者</h4><p>明确这两者的关系在Delegate的应用中显得尤为重要，在ViewController.m中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123;</span><br><span class="line">    if ([segue.identifier isEqualToString:@&quot;Segue_ID_AB&quot;]) &#123;</span><br><span class="line">        ViewController2 *sceneBVC = segue.destinationViewController;</span><br><span class="line">        sceneBVC.delegate = self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成上面代码之后可能会收到来自编译器的报错，不过不用担心，等我们完成所有步骤，把代码完善了以后就没问题了。</p><p>这里最重要的就是<strong>prepareForSegue</strong>方法的使用，该方法的完整描述是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</span><br></pre></td></tr></table></figure><p>segue：用以描述一个跳转的相关信息，比如是A controller 跳转至B controller页面，则我们可以通过它获取到Acontroller的一个实例对象，和B controller的一个实例对象。注意调用这个函数的时候，跳转行为还没有发生，所以我们可以在这个方法内部，获取到B controller的实例，然后传递一些参数过去。</p><p>sender：表示是谁触发了这次跳转。因为是从A—&gt;B,所以这个sender可能是A controller里面的任何一个对象。我们可以用它来区分同一个页面上触发的不同的跳转行为。</p><p>比如：A页面上有2个按钮x和y，当点击x按钮时，就跳B页面；当点击y按钮时，就跳C页面。所以当点击x按钮时，触发了一个跳转，UIStoryboard的运行时就会去调用A controller里面的这个函数，其中sender就是x按钮。点击y按钮类似。这时候我们就可以判断如果sender是x按钮，则给B页面传递数据；如果按钮时y，则给C页面传递数据。或者是其他业务逻辑。</p><blockquote><p>相关资料：<a href="http://blog.csdn.net/shang_ri_la/article/details/24427981">storyboard之prepareForSegue</a></p></blockquote><h4 id="被委托者遵循Delegate协议"><a href="#被委托者遵循Delegate协议" class="headerlink" title="被委托者遵循Delegate协议"></a>被委托者遵循Delegate协议</h4><p>在ViewController.h中引入ViewController2.h，并让ViewController遵循委托者协议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">//引入</span><br><span class="line">#import &quot;ViewController2.h&quot;</span><br><span class="line">//让ViewController遵循委托者协议</span><br><span class="line">@interface ViewController : UIViewController &lt;ViewController2Delegate&gt;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *showInformation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="被委托者重写Delegate内的方法"><a href="#被委托者重写Delegate内的方法" class="headerlink" title="被委托者重写Delegate内的方法"></a>被委托者重写Delegate内的方法</h4><p>在ViewController.m中，重写Delegate内的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewController:(ViewController2 *)sceneBVC didInputed:(NSString *)string&#123;</span><br><span class="line">    self.showInformation.text = string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试与总结"><a href="#测试与总结" class="headerlink" title="测试与总结"></a>测试与总结</h3><p>先上图！</p><p><img src="http://image.dapaner.top/Snip20151019_77.png"><br><img src="http://image.dapaner.top/Snip20151019_78.png"><br><img src="http://image.dapaner.top/Snip20151019_79.png"></p><p>这样，我们就完整的解决了这个看似简单实际暗藏玄机的题目了。</p><p>Delegate实现了不同场景之间的数据交互。它属于事件驱动的范畴，只有当某一事件触发时，Delegate才被调用。从这到例题中我们使用到的Delegate还只是很少的一部分，想要熟练的使用并且有深入的理解还需要更多的探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;继上次通过Storyboard完成了简单地页面跳转之后，我发现了很多问题，比如从第二个页面回跳到第一个页面，并不是依照正向跳转那样简单地模仿就好，在实际运行中会发现程序报错了。这次，我们将结合一道经典的题目，完成对页面跳转、传值以及附带的相关键盘输入的问题总结。题
      
    
    </summary>
    
      <category term="iOS" scheme="http://dapaner.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://dapaner.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Storyboard页面跳转</title>
    <link href="http://dapaner.top/2015/10/12/iOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Storyboard%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
    <id>http://dapaner.top/2015/10/12/iOS开发——Storyboard页面跳转/</id>
    <published>2015-10-12T05:42:47.000Z</published>
    <updated>2019-06-16T07:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Storyboard（分镜or故事板）一词源于电影业，在漫画创作中也很常见，它在电影或者漫画创作中扮演着“诠释者”的角色，主要是对作品中的各种事件进行描述，比如它们的发生顺序、观察角度、相互之间的关联等等。</p><p>苹果自iOS5开始推出了开发领域的Storyboard，并建议UI开发使用，旨在代替历史悠久的历史悠久的NIB&#x2F;XIB。以往的XIB的使用方法是一个viewController对应一个nib文件。StoryBoard的最大作用就是把这些nib文件组织起来，放在一个文件——MainStoryBoard.storyboard里，同时在此文件里面提供了不同试图间的切换。</p><p>虽然Storyboard的出现极大地提升了UI开发的效率且降低了开发难度，但需要注意的一点就是，我建议Storyboard与代码相结合的方式来做UI开发，具体为什么，大家在亲身实践过之后自然会明白。</p><p>相关链接：</p><p><a href="http://leopard168.blog.163.com/blog/static/1684718442014183256520/">《iOS开发之美》节选： 谈谈 xib 与 storyboard的关系</a></p><p><a href="http://www.cocoachina.com/cms/tags.php?/storyboard/">CocoaChina_Storyboard</a></p><hr><h3 id="初识Storyboard"><a href="#初识Storyboard" class="headerlink" title="初识Storyboard"></a>初识Storyboard</h3><p>在最新版的Xcode7当中，项目新建时已经没有了原来的Empty Application（空应用），初学iOS的话，默认的最简单的模板是默认采用Storyboard开发的，所以Storyboard的使用势在必行，具体的介绍或者一些简单的用法网上很多，可以自行Google。</p><p><img src="http://image.dapaner.top/Snip20151011_24.png"></p><hr><h3 id="Storyboard实现页面跳转"><a href="#Storyboard实现页面跳转" class="headerlink" title="Storyboard实现页面跳转"></a>Storyboard实现页面跳转</h3><p>网上去搜“Storyboard实现页面跳转”教程一大把，图文并茂甚是清楚，能够完成相应的功能，但是，按照图片做完这些步骤，虽然实现了功能，但是还是不明白Storyboard具体的实现机制。</p><p>首先我们要明白的是，虽然在Storyboard中我们只需要通过简单的拖拉就可以将很多元素集成到我们的界面当中去，但是我们还需要将它们进行关联。这才是问题的关键所在。我们可以往Storyboard中添加ViewController，通过ViewController来管理界面，可是拖进来一个ViewController之后我们要在哪里写代码来控制这个ViewController呢？我们又该编写什么样的代码来实现相应的功能呢？这才是问题的关键所在。</p><h4 id="Storyboard与ViewController的关联开始"><a href="#Storyboard与ViewController的关联开始" class="headerlink" title="Storyboard与ViewController的关联开始"></a>Storyboard与ViewController的关联开始</h4><p>那么，就从Storyboard与ViewController的关联开始。</p><p>新建一个名为“learnStoryboard”的项目，为了以后演示方便，我们先取消它默认的视窗大小，改为适配我们的虚拟机ipnone机型大小。</p><p><img src="http://image.dapaner.top/Snip20151012_27.png"></p><p>改完后我们开始向Storyboard中添加一个ViewController。</p><p><img src="http://image.dapaner.top/Snip20151012_28.png"></p><p>好了。到此为止我们已经拥有了两个ViewController，一个是新建项目时系统默认为我们添加的，也是程序一运行就进入的根视图；另一个就是我们刚刚添加进去的了。我们可以看到左侧的navigato面板，我们的工程文件里面有两个ViewController.h和ViewController.m文件，他们就是对系统默认的ViewController进行控制的文件。那我们要做的就是依葫芦画瓢，自己创建对我们的ViewController的控制文件。</p><p>在工程中新建Cocoa Touch Class模板，注意在Subclass选项中选择UIViewController。</p><p><img src="http://image.dapaner.top/Snip20151012_30.png"></p><p>新建完成之后我们可以看到这两个文件：</p><p><img src="http://image.dapaner.top/Snip20151012_31.png"></p><p>接下来就是最后一步了，两者的关联，其实挺简单的：</p><p><img src="http://image.dapaner.top/Snip20151012_34.png"></p><h4 id="ViewController有了，视图呢？"><a href="#ViewController有了，视图呢？" class="headerlink" title="ViewController有了，视图呢？"></a>ViewController有了，视图呢？</h4><p>在进行完对ViewController的关联后，我们先停一下，心急吃不了热豆腐嘛。先来分析分析ViewController到底是个什么东西，它又是怎么工作的。</p><p>我们打开进入ViewController.h，看代码~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>简简单单的三行，我们发现我们的ViewController类其实是继承自一个叫做UIViewController的类，那，追根溯源，command进去（按住command键点击）……然后就吓尿了有木有……怎么这么乱！</p><p><img src="http://image.dapaner.top/Snip20151012_35.png"></p><p>这时候不要慌，我们慢慢看，找到这一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(null_resettable, nonatomic,strong) UIView *view;</span><br></pre></td></tr></table></figure><p>这是什么？没有错，这是UIViewController类定义的一个实例变量，来看看它的类型——<strong>UIView</strong>。那，很明显了，什么意思呢，我们的 ViewController继承了一个叫做UIViewController的类，而 UIViewController类中定义了一个UIView类型的实例变量，这个UIView类型的变量就是一个我们可以看见的界面，也就是说，</p><p><strong>我们刚刚新建的ViewController里面包含一个可以看见的界面</strong></p><p>那废话这么多有什么用呢？用处就在于我们了解了ViewController为什么可以呈现出一个视图，明明没有代码，怎么就能进行UI编辑呢？答案就在这了。关于其他的一些细节，还是老办法，找到UIViewController，command进去，慢慢研究即可，再次不多赘述。</p><h4 id="添加控件，实现Storyboard页面跳转"><a href="#添加控件，实现Storyboard页面跳转" class="headerlink" title="添加控件，实现Storyboard页面跳转"></a>添加控件，实现Storyboard页面跳转</h4><p>说了那么多，开始我们正式的应用！</p><p>就像添加ViewController那样，我们向两个ViewController中分别添加两个Button，命名为“下一页”和“上一页”。为了显示区别，我们分别向两个视图中再添加两个Image View，也让我们的小例子看上去更美观一些。</p><p>添加完成之后是⬇️这个样子的，我们获得了这两个美美的视图，接下来就是进行跳转的关联了。</p><p><img src="http://image.dapaner.top/Snip20151012_36.png"></p><p>按住control键，点击“下一页”这个Button，拖向第二个ViewController：</p><p><img src="http://image.dapaner.top/Snip20151012_39.png"></p><p>选择页面跳转的方式：</p><p><img src="http://image.dapaner.top/Snip20151012_40.png"></p><p>选择完成之后，进行Storyboard Segue配置：</p><p><img src="http://image.dapaner.top/Snip20151012_42.png"></p><p>ok!这时候我们command+R，就已经可以实现从第一页到第二页的跳转了。接下来我们要实现的是从第二页点击“上一页”按钮，来返回第一页。</p><p>那，你会不会说，这还不简单，像上面那样操作就好了。</p><p>呵呵。</p><p>是不是不行，是不是出错了？</p><p>我想说明一点的是，我们不能单单只学会用Storyboard这种傻瓜式的操作（暂且称之为傻瓜式，其实并不是）来完成UI编程。前文已经提到了，最好的方式是<strong>Storyboard+代码</strong>来进行UI编程。那么对于“返回上一页”这一功能，我们就得用Storyboard+代码的方式来实现。</p><p>我们首先用上面的方法创建从”下一页“这个Button到第一页的关联。</p><p><img src="http://image.dapaner.top/Snip20151012_48.png"></p><p>然后打开辅助的编辑页面：</p><p><img src="http://image.dapaner.top/Snip20151012_44.png"></p><p>进入后，我们现在可以同时看到Storyboard编辑页面和SecondViewController.m编辑页面，我们按下control键，单击SecondViewController中的“上一页”Button拖入SecondViewController.m代码中，位置如下</p><p><img src="http://image.dapaner.top/Snip20151012_45.png"></p><p>接下来SecondViewController.m文件会自动生成一段返回值类型为“IBAction“的函数代码，用来捕捉SecondViewController中的Button按钮点击以后的事件，其实就是一个事件监听。我们要对这个方法进行命名，为表示清楚，我们这里命名为”backToFirst“，点击”connect“，代码就会生成了。</p><p><img src="http://image.dapaner.top/Snip20151012_46.png"><br><img src="http://image.dapaner.top/Snip20151012_47.png"></p><p>好了，Button对象已经和代码相关联了，我们怎样完成功能呢？上代码！</p><p>编辑SecondViewController.m，在刚才生成的backToFirst方法中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSegueWithIdentifier:@&quot;toFirst&quot; sender:self];</span><br></pre></td></tr></table></figure><p>没有错，我们在<code>performSegueWithIdentifier</code>的第一个参数传入了上面我们创建的”下一页“这个Button到第一页的关联的Segue的标示符。意义就是通过这个Segue去往想去的视图。</p><p><img src="http://image.dapaner.top/Snip20151012_51.png"><br><img src="http://image.dapaner.top/Snip20151012_52.png"></p><p>这样，我们就完成了界面的跳转了。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;Storyboard（分镜or故事板）一词源于电影业，在漫画创作中也很常见，它在电影或者漫画创作中扮演着“诠释者”的角色，主要是对作品中的各种事件进行描述，比如它们的发生顺序、观察角度、相互之间的关联等等。&lt;/p&gt;
&lt;p&gt;苹果自iOS5开始推出了开发领域的Stor
      
    
    </summary>
    
      <category term="iOS" scheme="http://dapaner.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://dapaner.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>从几只小爬虫开始</title>
    <link href="http://dapaner.top/2015/10/06/%E4%BB%8E%E5%87%A0%E5%8F%AA%E5%B0%8F%E7%88%AC%E8%99%AB%E5%BC%80%E5%A7%8B/"/>
    <id>http://dapaner.top/2015/10/06/从几只小爬虫开始/</id>
    <published>2015-10-06T05:32:02.000Z</published>
    <updated>2019-06-22T09:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>人生苦短，我用Python。</p></blockquote><blockquote><p><a href="http://reliscore.com/blog/why-every-programmer-should-learn-python-or-ruby/">Why every programmer should learn Python or Ruby</a></p></blockquote><p>更新记录</p><p>2015-10-12 使用代理</p><hr><h3 id="简单地图片下载爬虫"><a href="#简单地图片下载爬虫" class="headerlink" title="简单地图片下载爬虫"></a>简单地图片下载爬虫</h3><p>废话不多说，来看第一个例程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">req = urllib.request.urlopen(<span class="string">&#x27;http://placekitten.com/g/500/600&#x27;</span>)</span><br><span class="line">response = urllib.request.urlopen(req)</span><br><span class="line"></span><br><span class="line">cat_img = response.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cat_500_600.jpg&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(cat_img)</span><br></pre></td></tr></table></figure><p>这是最初级的一个实例，上面这个爬虫从这个<a href="http://placekitten.com/">猫奴网站</a>下载了一可爱的小猫。这算是最简单的一个python爬虫了，只用到了一个urlopen方法。</p><p>通过上面的例程搞懂以下几个问题：</p><ul><li>urllib模块有什么作用</li><li>urlopen函数的使用</li><li>文件的open操作</li><li>with语句的用法</li></ul><p>查阅一番资料和Python的API文档，可以得到以下答案：</p><ul><li><p>urllib模块是Python的一个获取url（Uniform Resource Locators，统一资源定址器）的模块。</p></li><li><p>urlopen函数提供了一个非常简洁的接口，使得Python用各种各样的协议获取url。对请求的url返回一个response对象。这个response是一个file-like的对象，能用.read()函数操作这个response对象。</p></li><li><p>**fp &#x3D; open(“文件名”,打开模式)**直接打开一个文件，如果文件不存在则创建文件</p></li></ul><blockquote><p><img src="http://image.dapaner.top/Snip20151007_17.png" alt="图一"></p></blockquote><ul><li>with 语句是从 Python 2.5 开始引入的一种与<strong>异常处理</strong>相关的功能,从 2.6 版本开始缺省可用（参考 What’s new in Python 2.6? 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。——源自<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/">《浅谈 Python 的 with 语句》</a></li></ul><hr><h3 id="通过爬虫实现在线翻译"><a href="#通过爬虫实现在线翻译" class="headerlink" title="通过爬虫实现在线翻译"></a>通过爬虫实现在线翻译</h3><p>在有了以上基础以后，开始摸索更为复杂的爬虫。第二个例程要实现通过爬虫使用有道词典的在线翻译。</p><p>还是先上源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">content = <span class="built_in">input</span>(<span class="string">&quot;what do you want to translate?&quot;</span>)</span><br><span class="line">url = <span class="string">&#x27;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=null&#x27;</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line">data[<span class="string">&#x27;type&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;i&#x27;</span>] = content</span><br><span class="line">data[<span class="string">&#x27;doctype&#x27;</span>] = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;xmlVersion&#x27;</span>] = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;keyfrom&#x27;</span>] = <span class="string">&#x27;fanyi.web&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;ue&#x27;</span>] = <span class="string">&#x27;UTF-8&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;action&#x27;</span>] = <span class="string">&#x27;FY_BY_CLICKBUTTON&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;typoResult&#x27;</span>] = <span class="string">&#x27;true&#x27;</span></span><br><span class="line"></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(url, data)</span><br><span class="line">html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">json.loads(html)</span><br><span class="line">target = json.loads(html)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;result:%s&quot;</span>% (target[<span class="string">&#x27;translateResult&#x27;</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="string">&#x27;tgt&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>比第一个复杂了好多。不着急，一行一行看。</p><p>相比于第一个例程里只有urllib.request模块，这次我们多导入了两个模块<strong>urllib.parse</strong>和<strong>json</strong>。先不管这些，让我们先来分析一下如何实现使用有道词典的在线翻译。</p><p>打开Chrome进入有道翻译的页面，我们先简单看一下翻译“i love you”时，浏览器与服务器之间的交互，顺便了解我们的代码。</p><p>进入“审查元素”页面，我们在输入完“i love you”之后点击翻译，看到“Network”下一大堆浏览器与服务器之间的交互。</p><p><img src="http://image.dapaner.top/Snip20151007_18.png" alt="图二"></p><p>我们点击进入第一个浏览器向服务器提交的POST请求，来分析下想要用代码模拟人的操作，需要些什么。</p><p><img src="http://image.dapaner.top/Snip20151006_11.png" alt="图三"><br><img src="http://image.dapaner.top/Snip20151006_12.png" alt="图四"></p><p>如上图所示，我们要代码实现交互，就要模拟浏览器，向服务器提交POST。那么如何完成呢，就要接住urlopen这个函数了。查看API文档，我们找到urlopen这个函数，看看他到底是如何使用的：</p><p><img src="http://image.dapaner.top/Snip20151006_13.png" alt="图五"></p><p>urlopen函数在定义时可以传两个参数分别为<strong>url</strong>和<strong>data</strong>。url为我们实际需要访问的链接，这里要特别注意，url参数的值必须为图三中的Request URL梭织链接，而并非浏览器地址栏中的url。而data参数为字典类型，内容就是我们要向服务器提交的POST内容，也就是图四中From Data的内容了，于是我们在代码（第6~16行）中直接定义即可。</p><p>这里还有一点需要注意，在代码的第18行，有关字符编码。我们的POST要以字符串编码的形式提交，而我们定义的却是字典类型的数据，这时候就要借助urllib.parse模块中的**urlencode()**函数来实现转义。格式为“utf-8”（.encode(‘utf-8’)）。</p><p><img src="http://image.dapaner.top/Snip20151007_20.png" alt="图六"></p><p>好了。在爬取网页之前的准备工作就已经全部完成了，接下来我们进行爬取并打印response对象的内容：</p><p><img src="http://image.dapaner.top/Snip20151006_14.png" alt="图七"></p><p>没有错，我们获得了json格式的内容，那什么是json，json模块中有哪些函数，它们又如何使用？</p><p><img src="http://image.dapaner.top/Snip20151007_21.png"><br><img src="http://image.dapaner.top/Snip20151007_22.png" alt="图八"></p><p>接下来就是从json数据中提取出我们想要的内容了。使用**json.loads()**提取出字典后，打印就好了。</p><p><img src="http://image.dapaner.top/Snip20151006_15.png" alt="图九"></p><p>最后来测试下整体的效果：</p><p><img src="http://image.dapaner.top/Snip20151007_23.png" alt="图十"></p><hr><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>当我们用python爬虫进行一些比较密集的爬取（比如下载某网站的所有图片啊）时，服务器会对我们进行封锁，那么我们要如何继续疯狂的爬啊爬呢？</p><p>没有错，就是使用代理。我们用很多个不同的ip地址去登陆服务器，这样服务器就会误认为是很多个不同的人在链接，所以就不会封锁你咯。再搭配上面提到的对Headers的设置，我们就可以快速的进行爬取了。</p><p>在Python中使用代理一共有如下几步：</p><ul><li>设置一个字典作为参数，要这样的格式：{‘类型’:‘代理ip:端口号’}</li><li>调用urllib.request.ProxyHandler()方法，传入我们刚刚设置的字典参数</li><li>定制、创建我们的opener，用来获取url</li><li>安装我们“私人定制”的opener</li><li>调用opener</li></ul><p>呐，知道了这些，我们就来实践一下，使用代理来访问一个宝岛台湾的网站<a href="http://www.whatismyip.com.tw/">whatismyip</a>,这是一个很有意思的玩意儿，这个网站只有一个作用那就是显示你当前访问它使用的IP地址。</p><p>好，先来看看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.whatismyip.com.tw&#x27;</span></span><br><span class="line"></span><br><span class="line">iplist = [<span class="string">&#x27;222.88.236.236:843&#x27;</span>,<span class="string">&#x27;125.131.193.43:80&#x27;</span>,<span class="string">&#x27;183.252.18.131:8080&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">proxy_support = urllib.request.ProxyHandler(&#123;<span class="string">&#x27;http&#x27;</span>:random.choice(iplist)&#125;)</span><br><span class="line"></span><br><span class="line">opener = urllib.request.build_opener(proxy_support)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opener.addheaders = [(<span class="string">&#x27;User-Agent&#x27;</span>,<span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.152 Safari/537.36&#x27;</span>)]</span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(html)</span><br></pre></td></tr></table></figure><p>我们还是一句一句的来分析，首先是我们要访问的域名，不多说。往下走，我们新建一个列表，来储存待用的ip地址。至于代理ip的话，网上有好多，百度一下，copy过来。</p><p>接下来我们定义了一个proxy_support，后面用的是urllib.request.ProxyHandler()方法，从这一句开始，我们开始使用代理。然后我们自定义了一个opener，并且安装了它</p><p>还是从文档开始看起：</p><p><img src="http://image.dapaner.top/Snip20151012_54.png" alt="图十一"><br><img src="http://image.dapaner.top/Snip20151012_55.png" alt="图十二"></p><p>功能就是大概我们描述的样子。接下来的的大家都已经熟悉了，最后我们打印获得的网页HTML源码，来看我们到底用了什么ip地址去访问：</p><p><img src="http://image.dapaner.top/Snip20151012_56.png" alt="图十三"></p><p>再运行一次，看看，两次的访问ip可是不一样的咧。</p><p><img src="http://image.dapaner.top/Snip20151012_57.png" alt="图十四"></p><p>需要注意的一点是，这些代理ip可是每天都在变得，如果如果你想运行参考例程，最好是重新搜一下代理ip并更新代码中的iplist。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;人生苦短，我用Python。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://reliscore.com/blog/why-every-programmer-should-learn-p
      
    
    </summary>
    
      <category term="Python" scheme="http://dapaner.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://dapaner.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>史上最完全Mac安装Scrapy指南</title>
    <link href="http://dapaner.top/2015/10/04/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E5%85%A8Mac%E5%AE%89%E8%A3%85Scrapy%E6%8C%87%E5%8D%97/"/>
    <id>http://dapaner.top/2015/10/04/史上最完全Mac安装Scrapy指南/</id>
    <published>2015-10-04T06:51:06.000Z</published>
    <updated>2019-06-16T07:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>博主作为一名python爬虫爱好者，怎能不折腾下Scrapy？于是在折腾了两个下午之后，终于把Scrapy装在了Macbook上。说起来还真的是蛮坎坷的，网上大多是win和Linux下的安装教程，Mac端的安装教程实在是少的可怜，安装初期也是遇到各种各样的错误，经过一番摸索加实践，现总结出最完全的Mac端Scrapy安装指南。</p></blockquote><blockquote><p>更新记录<br>2015年10月5日 - 解决ImportError:cannot import name xmlrpc_client问题</p></blockquote><hr><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装开始前，你需要知道的几点注意事项和工具：</p><ul><li><p>MAC OS是自带python 2.7的，而目前Scrapy也只是在python 2.7版本较为稳定，所以你不需要再安装或者配置python环境了，只需要按步骤安装好Scrapy就好了。</p></li><li><p>作为一个想在Mac上用Scrapy的人，我觉得你应该是知道Homebrew和wget的吧。。。好吧如果你不知道那也没有关系，请移步<a href="http://brew.sh/index_zh-cn.html">Homebrew</a>。</p></li><li><p>安装好Homebrew，wget并学会使用（很简单的）。</p></li><li><p>如果你是开发人员，那么别墨迹了，把Xcode装上吧。如果你不是，那装不装倒是无所谓。</p></li></ul><p>好了，到现在为止我们已经做完了准备工作，接下来我们就开始进入正篇环节——Scrapy安装。</p><h3 id="安装pip工具包"><a href="#安装pip工具包" class="headerlink" title="安装pip工具包"></a>安装pip工具包</h3><p>这个必须安装，是基于python的管理工具包。在这里就不多废话了，既然知道Scrapy，没理由不知道pip。我们已经装过了wget，现在我们就用它来获取pip，很简单，打开终端，下面这行命令敲进去执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br></pre></td></tr></table></figure><p>接下来安装pip：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python get-pip.py</span><br></pre></td></tr></table></figure><p>搞定。</p><h3 id="pip源修改"><a href="#pip源修改" class="headerlink" title="pip源修改"></a>pip源修改</h3><p>注意，这一步非常重要，很多人在安装Scrapy不成功的第二大原因（稍后再说第一大）就是这个，一定要改啊。博主一想起这个就是泪牛满面啊，折腾的时间大部分都浪费在这里了。</p><p>安装完成pip之后，默认的时官方源可能会被我大天朝的长城K.O.掉，我们需要对pip源进行修改，使用咱们国内的源。</p><p>首先创建配置文件，默认情况下Mac端好像是没有pip的配置文件的，我们需要自行创建。打开终端，在HOME下创建.pip目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir .pip</span><br></pre></td></tr></table></figure><p>接下来创建配置文件pip.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch pip.conf</span><br></pre></td></tr></table></figure><p>接下来编辑配置文件，随便使用什么编辑器打开刚刚新建的pip.conf文件，输入以下两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.mirrors.ustc.edu.cn/simple</span><br></pre></td></tr></table></figure><p>输入完成后保存退出即可，至此，pip源就修改完了，可以进行下一步了。</p><blockquote><p>有一点要说明一下，就是pip源的问题，国内目前的pipy镜像主要有以下几个：</p></blockquote><blockquote><p><a href="http://pypi.douban.com/">http://pypi.douban.com/</a>  豆瓣</p></blockquote><blockquote><p><a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a>  华中理工大学</p></blockquote><blockquote><p><a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a>  山东理工大学</p></blockquote><blockquote><p><a href="http://pypi.mirrors.ustc.edu.cn/">http://pypi.mirrors.ustc.edu.cn/</a>  中国科学技术大学</p></blockquote><blockquote><p><a href="http://pypi.v2ex.com/">http://pypi.v2ex.com/</a>    V2EX社区</p></blockquote><blockquote><p>大家可以看自己需要选择，用法都一样，只需要替换配置文件当中index-url的值即可。但<strong>不要忘记后面的&#x2F;simple目录！</strong></p></blockquote><h3 id="Command-Line-Tools安装"><a href="#Command-Line-Tools安装" class="headerlink" title="Command Line Tools安装"></a>Command Line Tools安装</h3><p>pip在安装Scrapy模块时依赖lxml模块，而pip的默认行为是下载源码进行编译。很多小伙伴在MAC终端中并没有指定C编译器的环境变量啊，找不到include文件夹啊，找不到xmlversion.h文件啊等等问题。木有错，这就是大部分伙子装Scrapy遇到的最大问题！</p><p>为了防患于未然，我们先不要着急安装Scrapy，pip源修改完成之后，我们要先回到HOME进行Command Line Tools安装，终端下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select —install</span><br></pre></td></tr></table></figure><p>不管你有没有装Xcode，接下来你只要按照提示一直点确定就好了。</p><h3 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a>安装Scrapy</h3><p>现在做完以上几步之后，我们只需要执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install Scrapy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就可以了，如果没有lxml或者OpenSSL，pip会自动帮你装上的。</p><p>接下来就是等待安装完成了。</p><h3 id="解决ImportError-cannot-import-name-xmlrpc-client问题"><a href="#解决ImportError-cannot-import-name-xmlrpc-client问题" class="headerlink" title="解决ImportError:cannot import name xmlrpc_client问题"></a>解决ImportError:cannot import name xmlrpc_client问题</h3><p>安装完成之后，终端下输入如下命令查看Scrapy版本并验证是否成功，却发现出了问题，提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError:cannot import name xmlrpc_client</span><br></pre></td></tr></table></figure><p>如下图所示<br><img src="http://image.dapaner.top/Snip20151005_6.png"></p><p>网上无论如何也找不到解决方案，无奈之下翻墙Google，找到了某外国友人的解决方案。至此，问题告破。</p><p>终端下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /Library/Python/2.7/site-packages/six*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six*</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install six</span><br></pre></td></tr></table></figure><p>卸载掉six并重装，再次查看Scrapy版本，搞定。</p><p><img src="http://image.dapaner.top/Snip20151005_7.png"><br><img src="http://image.dapaner.top/Snip20151005_9.png"></p><hr><p>至此，Scrapy已经成功安装在你的Mac上了，按照博主的步骤一步一步来的话应该是不会出现什么问题的，接下来就是开始尽情地爬啊爬了~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;博主作为一名python爬虫爱好者，怎能不折腾下Scrapy？于是在折腾了两个下午之后，终于把Scrapy装在了Macbook上。说起来还真的是蛮坎坷的，网上大多是win和Linux下的安装教程，Mac端的安装教程实在是少的可怜，安装初期
      
    
    </summary>
    
      <category term="Python" scheme="http://dapaner.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://dapaner.top/tags/Python/"/>
    
      <category term="Scrapy" scheme="http://dapaner.top/tags/Scrapy/"/>
    
      <category term="爬虫" scheme="http://dapaner.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>我为什么选择Mac</title>
    <link href="http://dapaner.top/2015/10/02/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Mac/"/>
    <id>http://dapaner.top/2015/10/02/我为什么选择Mac/</id>
    <published>2015-10-02T14:22:33.000Z</published>
    <updated>2019-06-23T09:25:25.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>从了解开始，由外及内，包括软硬件及使用感受，系统详细的描述我使用MBP一周以来的种种。本文提到的相关软件我将会在不久之后专门整理供大家参考。</p></blockquote><blockquote><p>扩展阅读：</p><ul><li><a href="http://www.douban.com/group/topic/27959447/">Macbook Pro入手一月有余使用感受</a></li><li><a href="http://www.jianshu.com/p/c956d8dbce45">Mac优雅使用指南——一个码字民工的Macbook使用心得</a></li></ul></blockquote><blockquote><p>更新记录<br>2015年10月5日 - Spotlight &amp; Alfred   Terminal &amp; iTerm<br>2015年10月3日 - Finder文件管理<br>2015年10月2日 - 触控板</p></blockquote><hr><p>2015年的初秋，博主在做校内实习，一个基于Android的企业内部通讯录项目。当项目临近尾声开始在虚拟机上测试APP时，陪伴了博主三年的联想小Y471A终于难以再堪重任，开始消极怠工，从打开ADT到开启虚拟机调试共耗时两小时。。。两小时，说实话，当一个急性子加完美主义控遇到此种情况的结果那只能有一个——他的内心是崩溃的。</p><p>考虑到接下来的毕业设计，以及以后的工作和我这个爱折腾的癖性，决定入手Macbook Pro，至于为什么，我不想多说，用过的人都清楚。于是乎，在9月18号前趁着官网教育优惠，入了13.3寸的高配MBP，考虑到未来几年的使用情况，定制了16G内存，对一个穷学生来讲，价格略贵。以前看过知乎上某答主（时间久远不记得了，后来去找也没找到）的观点，本人十分赞同，Macbook Pro作为一件生产工具，一件高效的生产工具，它并不贵，值这个价格。此外，这也不是一篇导购贴or装X贴，土豪和装X党请绕道。</p><p>首先贴一下MBP配置~~</p><div  align="center">    <img src="http://image.dapaner.top/Snip20151002_4.png" width = "510" height = "340" align=center /></div><hr><h3 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h3><p>作为一名软件工程专业的学生，也就是将来的程序猿，自己先把自己定义为“专业人士”。那么，在考虑入坑Macbook Pro时，自然要考虑更多的方面，不仅仅是一台笔记本电脑的问题了，它以后可是要给你挣娶姑娘生娃娃的原始资本的。</p><p>作为一只刚从win转到MAC OS的小白，在购机之初下了单还没到货的那段时间仔细的研究MAC OS的使用，当然，网上教程什么的很多。我是从学校图书馆借了一本《苹果OS X Mavericks 10.9应用大全》从头到尾把基本的操作基本搞清楚了。至少能自己搞定开机并激活吧？还有一些基本的软件安装之类的。</p><h3 id="硬件及外观"><a href="#硬件及外观" class="headerlink" title="硬件及外观"></a>硬件及外观</h3><p>苹果的工业设计已经不用多说，说道这里还是要吐槽下，其实大部分人选择Mac的理由就是好看能装X，但他们又并不能摆脱win下的操作习惯以及对影音娱乐的需求，于是便装个双系统拿Mac使Windows，每次看见这个就有一种好白菜让猪拱了的感觉。。。当初选择13.3寸的机型主要还是考虑到便携性，毕竟不是在家里使用，需要带在身上到处跑。拿到本本后第一感觉就是轻，作为一台性能如此强大的笔记本，它能做到如此轻，真的很惊人。经过一周的使用，个人觉得作为男生来讲的话，13寸和15寸在便携性上差别并不是很大，都是没问题的，个人比较喜欢mini一点的，再考虑到价格的问题，13.3寸是必然选择。</p><h3 id="触控板"><a href="#触控板" class="headerlink" title="触控板"></a>触控板</h3><p>让你忘记鼠标！让你忘记鼠标！让你忘记鼠标！</p><p>说三遍。</p><p>没有错，在使用Macbook一周后，我已经成功的脱离鼠标成为键盘流。快捷键什么的放在后面说，首先来讲触控板。第一次使用的感觉就是足够人性化，它让你像使用iPhone或者iPad那样使用笔电。是真正意义上的触控，通过多种手势完成多种功能，具体手势什么的网上好多，就不多说了。</p><p>在原先使用小Y时特别不理解网上的Mac党说触控板怎么怎么样，心想不就是触摸板么，我小Y上面也有的啊。于是现在被打脸了。讲一下具体的区别。笔电上的传统触控板功能一共有三个，如下：</p><ul><li>移动光标位置进行选择</li><li>点按完成鼠标点击（包括左键和右键）</li><li>上下滑动滚动条</li></ul><p>而Macbook触控板的功能。。。有点夸张了，我只说几个在使用过程中让人更舒服的：</p><ul><li>双指滑动完成网页等前进后退</li><li>双指点按代替传统右键（谁用谁知道）</li><li>缩放，具体操作跟iPhone一样，怎么用怎么习惯</li><li>三指上滑列出所有当前正在运行的程序，随意切换</li><li>张开拇指和其他三个手指回到桌面（这个对于手大的人来讲可能比较费劲。。。）</li></ul><p>就这样，如果同样是在没有鼠标的情况下，完成同样的功能，比如切换个应用程序什么的，传统笔电触控板可能要双手齐用还要多个步骤才能完成，而Macbook触控板只需要简单地三指上滑，轻触一下即可，效率简直不是一般的高。</p><h3 id="Finder文件管理"><a href="#Finder文件管理" class="headerlink" title="Finder文件管理"></a>Finder文件管理</h3><p>对于刚刚使用Mac OS的人来讲，这是难以适应的。首先，这个相当于win下“我的电脑”的东西进去后并没有什么磁盘分区，给人感觉只是几个赤裸裸的文件夹。这个问题倒还好说，玩Mac最爽的就是不用担心什么垃圾文件填充满的臃肿的系统盘了。</p><p>要说最不习惯的地方，那就是只使用原生Finder进行文件管理而不用什么插件的话，你是不能进行原来win上对文件的剪切粘贴这样的移动操作的，你只能打开新窗口或者向边栏中现有的文件夹拖动文件以完成移动。这样是很令人不爽的，因为有时候你需要将某个文件移动到某文件夹下的二级目录或者更多级目录，这样的话就比较麻烦了，你只能通过打开一个新的窗口来完成操作，这样来看显然是不高效的。</p><p>所以，这时候我们就需要一些插件来解决这个问题了，这些第三方插件会使你的Finder更加强大，使用起来也会更加方便。我使用的是<strong>TotalFinder</strong>，当然还有其他的更多的第三方插件，看个人喜好了。当然，说起来倒也没那么麻烦，如果时间久了，快捷键都熟悉了，不用插件也是很快的，博主刚刚使用MBP一周，尚有好多快捷键不是很熟悉，觉得还是用插件更快一些。作为一个重度整理癌患者和完美主义控，是绝对不允许Finder里面乱七八糟的不是吗？</p><hr><h3 id="Launchpad"><a href="#Launchpad" class="headerlink" title="Launchpad"></a>Launchpad</h3><p>可以简单地理解为应用程序界面，就是一个让你的笔电像iPad那样工作的东西。打开后是扑面而来的应用，想用哪个点哪个，各种嗨。类比于win下的开始菜单，MAC OS其实是封装了应用程序和其安装时产生的所有文件的，对用户显示的只有应用程序图标，省了看着心烦的那些乱七八糟的玩意儿。</p><hr><h3 id="Dock栏"><a href="#Dock栏" class="headerlink" title="Dock栏"></a>Dock栏</h3><p>重头戏！</p><p>如果你有先前使用Linux的经验，那么这个东西会让你感到亲切。Mac OS为了让桌面更加整洁，将用户常用的应用程序集成到Dock栏中，使用时觉得最方便的就是比原先win下从一堆图标中找你要的那个要快了许多。而且作为一个强迫症，我是受不了桌面上有一堆乱七八糟五花八门的应用图标的。</p><p>神奇效果下，窗口的呼出、最小化等也变得更加动感，非常有意思。通过一些简单的设置，可以让你的Dock使用更加舒服，这里就不推荐什么插件了，系统原生的就非常棒。</p><hr><h3 id="Spotlight-amp-Alfred"><a href="#Spotlight-amp-Alfred" class="headerlink" title="Spotlight &amp; Alfred"></a>Spotlight &amp; Alfred</h3><p>相比于win下的搜索，MAC OS的Spotlight简直强大到爆。在本本刚买回激活后，大概有几个小时的时间内（或者很快），Spotlight会对你的系统进行彻底的第一次检索，它不仅会包含系统内所有的文件，完成最基本的搜索功能，更可怕的是它可以直接关联相关应用程序进行功能上的使用。比如我可以在Spotlight下输入“book”，它不仅会检索到系统内所有的包含“book”关键字的文件，也可以直接进入“字典”查询“book”这个单词，也可以搜寻到包含“book”的你的信息或者文件。通过一些简单的设置，你还可以隐藏相关私密的搜索结果（你懂得~~），调整结果显示的顺序等等。非常方便。虽然博主在拿到本本的第一时间就装了Alfred，但是对于不喜欢折腾的人来说，Spotlight已经足够让你更加高效了。</p><p>那，什么是Alfred？</p><p>简单点讲，如果你用Spotlight而且感觉它很不错，是个威力巨大的武器，那Alfred就是足以毁灭宇宙的高端战力。</p><p>先不说Alfred是怎么回事，先聊聊什么人适合或者说必须要装这个东西。如果你是像博主一样的程序猿，装吧。如果你是学生，无论什么专业，装吧。如果你想简化一些日常的复杂的重复的操作，装吧。如果你用Mac…………装吧。好吧。好像说了一堆废话，总而言之，用Mac，没有理由不装Aflred，至少博主这么认为的。</p><p>它可以帮你快速的进行网络搜索，注意，不仅仅是百度那么简单，淘宝天猫一样，秒进秒搜，只需一键。它可以帮你快速翻译单词，不用打开任何应用。它可以查API，可以看天气，可以刷知乎，发微博…………好吧，你能想到的它都能，对，你想不到的它也能。</p><p>一切的一切源于<strong>Aflred</strong>+<strong>Workflows</strong>，至于怎么用，博主日后整理，此处先不多提。心急的小伙伴可自行Google。</p><hr><h3 id="Terminal-amp-iTerm"><a href="#Terminal-amp-iTerm" class="headerlink" title="Terminal &amp; iTerm"></a>Terminal &amp; iTerm</h3><p>到了这里，只是打算拿Mac当娱乐本用的伙伴可以跳到下一个章节了。</p><p>Terminal——终端，这个东西对于程序员来讲简直不能更熟悉了。MAC OS的内核是UNIX，博主大三使用的主力OS是类UNIX的Linux，所以对于折腾MAC OS的命令行也是充满了自信。</p><p>至于终端到底是个什么东西，怎么使用，就不多提了，内行自然清楚。先上个图：</p><p><img src="http://image.dapaner.top/Snip20151005_10.png"></p><p>经过大概整整一上午的功夫，博主的终端由系统默认的模样变成了上面的样子。使用的是<strong>iTerm</strong>+<strong>zsh</strong>+<strong>oh-my-zsh</strong>+<strong>robbyrussell</strong>的组合。用更加好用的<strong>iTerm</strong>代替了系统终端Terminal，把系统默认的Shell——bash改为<strong>zsh</strong>，使用了国外一个无聊的程序员做的<strong>oh-my-zsh</strong>来优化配置了zsh，主题使用的默认的<strong>robbyrussell</strong>。具体使用起来，那感觉简直棒.</p><hr><p>以上。</p><p>其实目前为止还只是初步体验，相信随着使用时间的加长，更多的技巧发觉会让Mac德使用体验更加nice！博主不久将专门整理Mac下使用的各种软件和插件，还有部分开发环境的搭建也将陆续整理出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;从了解开始，由外及内，包括软硬件及使用感受，系统详细的描述我使用MBP一周以来的种种。本文提到的相关软件我将会在不久之后专门整理供大家参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展阅读：&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="杂" scheme="http://dapaner.top/categories/%E6%9D%82/"/>
    
    
      <category term="Mac" scheme="http://dapaner.top/tags/Mac/"/>
    
  </entry>
  
</feed>
